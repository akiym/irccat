#!/usr/bin/env perl
# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"AE.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'AE';
  package AE;use AnyEvent ();our$VERSION=$AnyEvent::VERSION;1
AE

$fatpacked{"AnyEvent.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT';
  package AnyEvent;BEGIN {require "AnyEvent/constants.pl";&AnyEvent::common_sense}use Carp ();our$VERSION=7.11;our$MODEL;our@ISA;our@REGISTRY;our$VERBOSE;our%PROTOCOL;our$MAX_SIGNAL_LATENCY=$ENV{PERL_ANYEVENT_MAX_SIGNAL_LATENCY}|| 10;BEGIN {eval "sub TAINT (){" .(${^TAINT}*1)."}";delete@ENV{grep /^PERL_ANYEVENT_/,keys%ENV}if ${^TAINT};$ENV{"PERL_ANYEVENT_$_"}=$ENV{"AE_$_"}for grep s/^AE_// &&!exists$ENV{"PERL_ANYEVENT_$_"},keys%ENV;@ENV{grep /^PERL_ANYEVENT_/,keys%ENV}=()if ${^TAINT};$VERBOSE=length$ENV{PERL_ANYEVENT_VERBOSE}? $ENV{PERL_ANYEVENT_VERBOSE}*1 : 4;my$idx;$PROTOCOL{$_}=++$idx for reverse split /\s*,\s*/,$ENV{PERL_ANYEVENT_PROTOCOLS}|| "ipv4,ipv6"}our@post_detect;sub post_detect(&) {my ($cb)=@_;push@post_detect,$cb;defined wantarray ? bless \$cb,"AnyEvent::Util::postdetect" : ()}sub AnyEvent::Util::postdetect::DESTROY {@post_detect=grep $_!=${$_[0]},@post_detect}our$POSTPONE_W;our@POSTPONE;sub _postpone_exec {undef$POSTPONE_W;&{shift@POSTPONE}while@POSTPONE}sub postpone(&) {push@POSTPONE,shift;$POSTPONE_W ||= AE::timer (0,0,\&_postpone_exec);()}sub log($$;@) {if ($_[0]<= ($VERBOSE || 1)){local ($!,$@);require AnyEvent::Log;goto&log}0}sub _logger($;$) {my ($level,$renabled)=@_;$$renabled=$level <= $VERBOSE;my$logger=[(caller)[0],$level,$renabled];$AnyEvent::Log::LOGGER{$logger+0}=$logger}if (length$ENV{PERL_ANYEVENT_LOG}){require AnyEvent::Log}BEGIN {*_fh_nonblocking=AnyEvent::WIN32 ? sub($$) {ioctl $_[0],0x8004667e,pack "L",$_[1]}: sub($$) {fcntl $_[0],AnyEvent::F_SETFL,$_[1]? AnyEvent::O_NONBLOCK : 0}}sub fh_block($) {_fh_nonblocking shift,0}sub fh_unblock($) {_fh_nonblocking shift,1}our@models=([EV::=>AnyEvent::Impl::EV::],[AnyEvent::Loop::=>AnyEvent::Impl::Perl::],[Irssi::=>AnyEvent::Impl::Irssi::],[Event::=>AnyEvent::Impl::Event::],[Glib::=>AnyEvent::Impl::Glib::],[Event::Lib::=>AnyEvent::Impl::EventLib::],[Tk::=>AnyEvent::Impl::Tk::],[UV::=>AnyEvent::Impl::UV::],[Qt::=>AnyEvent::Impl::Qt::],[POE::Kernel::=>AnyEvent::Impl::POE::],[Wx::=>AnyEvent::Impl::POE::],[Prima::=>AnyEvent::Impl::POE::],[IO::Async::Loop::=>AnyEvent::Impl::IOAsync::],[Cocoa::EventLoop::=>AnyEvent::Impl::Cocoa::],[FLTK::=>AnyEvent::Impl::FLTK::],);our@isa_hook;sub _isa_set {my@pkg=("AnyEvent",(map $_->[0],grep defined,@isa_hook),$MODEL);@{"$pkg[$_-1]::ISA"}=$pkg[$_]for 1 .. $#pkg;grep $_ && $_->[1],@isa_hook and AE::_reset ()}sub _isa_hook($$;$) {my ($i,$pkg,$reset_ae)=@_;$isa_hook[$i]=$pkg ? [$pkg,$reset_ae]: undef;_isa_set}our@methods=qw(io timer time now now_update signal child idle condvar);sub detect() {return$MODEL if$MODEL;AnyEvent::log fatal=>"IO::Async::Loop::AnyEvent detected - that module is broken by\n" ."design, abuses internals and breaks AnyEvent - will not continue." if exists$INC{"IO/Async/Loop/AnyEvent.pm"};local $!;local$SIG{__DIE__};*detect=sub () {$MODEL};delete @{"AnyEvent::"}{@methods};undef@methods;if ($ENV{PERL_ANYEVENT_MODEL}=~ /^([a-zA-Z0-9:]+)$/){my$model=$1;$model="AnyEvent::Impl::$model" unless$model =~ s/::$//;if (eval "require $model"){AnyEvent::log 7=>"Loaded model '$model' (forced by \$ENV{PERL_ANYEVENT_MODEL}), using it.";$MODEL=$model}else {AnyEvent::log 4=>"Unable to load model '$model' (from \$ENV{PERL_ANYEVENT_MODEL}):\n$@"}}unless ($MODEL){for (@REGISTRY,@models){my ($package,$model)=@$_;if (${"$package\::VERSION"}> 0){if (eval "require $model"){AnyEvent::log 7=>"Autodetected model '$model', using it.";$MODEL=$model;last}else {AnyEvent::log 8=>"Detected event loop $package, but cannot load '$model', skipping: $@"}}}unless ($MODEL){for (@REGISTRY,@models){my ($package,$model)=@$_;if (eval "require $package" and ${"$package\::VERSION"}> 0 and eval "require $model"){AnyEvent::log 7=>"Autoloaded model '$model', using it.";$MODEL=$model;last}}$MODEL or AnyEvent::log fatal=>"Backend autodetection failed - did you properly install AnyEvent?"}}undef@models;undef@REGISTRY;push @{"$MODEL\::ISA"},"AnyEvent::Base";for (qw(time signal child idle)){undef &{"AnyEvent::Base::$_"}if defined &{"$MODEL\::$_"}}_isa_set;if ($ENV{PERL_ANYEVENT_STRICT}){require AnyEvent::Strict}if ($ENV{PERL_ANYEVENT_DEBUG_WRAP}){require AnyEvent::Debug;AnyEvent::Debug::wrap ($ENV{PERL_ANYEVENT_DEBUG_WRAP})}if (length$ENV{PERL_ANYEVENT_DEBUG_SHELL}){require AnyEvent::Socket;require AnyEvent::Debug;my$shell=$ENV{PERL_ANYEVENT_DEBUG_SHELL};$shell =~ s/\$\$/$$/g;my ($host,$service)=AnyEvent::Socket::parse_hostport ($shell);$AnyEvent::Debug::SHELL=AnyEvent::Debug::shell ($host,$service)}(shift@post_detect)->()while@post_detect;undef@post_detect;*post_detect=sub(&) {shift->();undef};$MODEL}for my$name (@methods){*$name=sub {detect;goto &{UNIVERSAL::can AnyEvent=>"SUPER::$name"}}}sub _dupfh($$;$$) {my ($poll,$fh,$r,$w)=@_;my ($rw,$mode)=$poll eq "r" ? ($r,"<&"): ($w,">&");open my$fh2,$mode,$fh or die "AnyEvent->io: cannot dup() filehandle in mode '$poll': $!,";($fh2,$rw)}package AE;our$VERSION=$AnyEvent::VERSION;sub _reset() {eval q{
        # fall back to the main API by default - backends and AnyEvent::Base
        # implementations can overwrite these.
  
        sub io($$$) {
           AnyEvent->io (fh => $_[0], poll => $_[1] ? "w" : "r", cb => $_[2])
        }
  
        sub timer($$$) {
           AnyEvent->timer (after => $_[0], interval => $_[1], cb => $_[2])
        }
  
        sub signal($$) {
           AnyEvent->signal (signal => $_[0], cb => $_[1])
        }
  
        sub child($$) {
           AnyEvent->child (pid => $_[0], cb => $_[1])
        }
  
        sub idle($) {
           AnyEvent->idle (cb => $_[0]);
        }
  
        sub cv(;&) {
           AnyEvent->condvar (@_ ? (cb => $_[0]) : ())
        }
  
        sub now() {
           AnyEvent->now
        }
  
        sub now_update() {
           AnyEvent->now_update
        }
  
        sub time() {
           AnyEvent->time
        }
  
        *postpone = \&AnyEvent::postpone;
        *log      = \&AnyEvent::log;
     };die if $@}BEGIN {_reset}package AnyEvent::Base;sub time {eval q{ # poor man's autoloading {}
        # probe for availability of Time::HiRes
        if (eval "use Time::HiRes (); Time::HiRes::time (); 1") {
           *time     = sub { Time::HiRes::time () };
           *AE::time = \&    Time::HiRes::time     ;
           *now      = \&time;
           AnyEvent::log 8 => "using Time::HiRes for sub-second timing accuracy.";
           # if (eval "use POSIX (); (POSIX::times())...
        } else {
           *time     = sub   { CORE::time };
           *AE::time = sub (){ CORE::time };
           *now      = \&time;
           AnyEvent::log 3 => "Using built-in time(), no sub-second resolution!";
        }
     };die if $@;&time}*now=\&time;sub now_update {}sub _poll {Carp::croak "$AnyEvent::MODEL does not support blocking waits. Caught"}sub condvar {eval q{ # poor man's autoloading {}
        *condvar = sub {
           bless { @_ == 3 ? (_ae_cb => $_[2]) : () }, "AnyEvent::CondVar"
        };
  
        *AE::cv = sub (;&) {
           bless { @_ ? (_ae_cb => shift) : () }, "AnyEvent::CondVar"
        };
     };die if $@;&condvar}our$HAVE_ASYNC_INTERRUPT;sub _have_async_interrupt() {$HAVE_ASYNC_INTERRUPT=1*(!$ENV{PERL_ANYEVENT_AVOID_ASYNC_INTERRUPT}&& eval "use Async::Interrupt 1.02 (); 1")unless defined$HAVE_ASYNC_INTERRUPT;$HAVE_ASYNC_INTERRUPT}our ($SIGPIPE_R,$SIGPIPE_W,%SIG_CB,%SIG_EV,$SIG_IO);our (%SIG_ASY,%SIG_ASY_W);our ($SIG_COUNT,$SIG_TW);sub _sig_add() {unless ($SIG_COUNT++){my$NOW=AE::now;$SIG_TW=AE::timer $MAX_SIGNAL_LATENCY - ($NOW - int$NOW),$MAX_SIGNAL_LATENCY,sub {}}}sub _sig_del {undef$SIG_TW unless --$SIG_COUNT}our$_sig_name_init;$_sig_name_init=sub {eval q{ # poor man's autoloading {}
        undef $_sig_name_init;
  
        if (_have_async_interrupt) {
           *sig2num  = \&Async::Interrupt::sig2num;
           *sig2name = \&Async::Interrupt::sig2name;
        } else {
           require Config;
  
           my %signame2num;
           @signame2num{ split ' ', $Config::Config{sig_name} }
                          = split ' ', $Config::Config{sig_num};
  
           my @signum2name;
           @signum2name[values %signame2num] = keys %signame2num;
  
           *sig2num = sub($) {
              $_[0] > 0 ? shift : $signame2num{+shift}
           };
           *sig2name = sub ($) {
              $_[0] > 0 ? $signum2name[+shift] : shift
           };
        }
     };die if $@};sub sig2num ($) {&$_sig_name_init;&sig2num}sub sig2name($) {&$_sig_name_init;&sig2name}sub signal {eval q{ # poor man's autoloading {}
        # probe for availability of Async::Interrupt 
        if (_have_async_interrupt) {
           AnyEvent::log 8 => "Using Async::Interrupt for race-free signal handling.";
  
           $SIGPIPE_R = new Async::Interrupt::EventPipe;
           $SIG_IO = AE::io $SIGPIPE_R->fileno, 0, \&_signal_exec;
  
        } else {
           AnyEvent::log 8 => "Using emulated perl signal handling with latency timer.";
  
           if (AnyEvent::WIN32) {
              require AnyEvent::Util;
  
              ($SIGPIPE_R, $SIGPIPE_W) = AnyEvent::Util::portable_pipe ();
              AnyEvent::Util::fh_nonblocking ($SIGPIPE_R, 1) if $SIGPIPE_R;
              AnyEvent::Util::fh_nonblocking ($SIGPIPE_W, 1) if $SIGPIPE_W; # just in case
           } else {
              pipe $SIGPIPE_R, $SIGPIPE_W;
              fcntl $SIGPIPE_R, AnyEvent::F_SETFL, AnyEvent::O_NONBLOCK if $SIGPIPE_R;
              fcntl $SIGPIPE_W, AnyEvent::F_SETFL, AnyEvent::O_NONBLOCK if $SIGPIPE_W; # just in case
  
              # not strictly required, as $^F is normally 2, but let's make sure...
              fcntl $SIGPIPE_R, AnyEvent::F_SETFD, AnyEvent::FD_CLOEXEC;
              fcntl $SIGPIPE_W, AnyEvent::F_SETFD, AnyEvent::FD_CLOEXEC;
           }
  
           $SIGPIPE_R
              or Carp::croak "AnyEvent: unable to create a signal reporting pipe: $!\n";
  
           $SIG_IO = AE::io $SIGPIPE_R, 0, \&_signal_exec;
        }
  
        *signal = $HAVE_ASYNC_INTERRUPT
           ? sub {
                my (undef, %arg) = @_;
  
                # async::interrupt
                my $signal = sig2num $arg{signal};
                $SIG_CB{$signal}{$arg{cb}} = $arg{cb};
  
                $SIG_ASY{$signal} ||= new Async::Interrupt
                   cb             => sub { undef $SIG_EV{$signal} },
                   signal         => $signal,
                   pipe           => [$SIGPIPE_R->filenos],
                   pipe_autodrain => 0,
                ;
  
                bless [$signal, $arg{cb}], "AnyEvent::Base::signal"
             }
           : sub {
                my (undef, %arg) = @_;
  
                # pure perl
                my $signal = sig2name $arg{signal};
                $SIG_CB{$signal}{$arg{cb}} = $arg{cb};
  
                $SIG{$signal} ||= sub {
                   local $!;
                   syswrite $SIGPIPE_W, "\x00", 1 unless %SIG_EV;
                   undef $SIG_EV{$signal};
                };
  
                # can't do signal processing without introducing races in pure perl,
                # so limit the signal latency.
                _sig_add;
  
                bless [$signal, $arg{cb}], "AnyEvent::Base::signal"
             }
        ;
  
        *AnyEvent::Base::signal::DESTROY = sub {
           my ($signal, $cb) = @{$_[0]};
  
           _sig_del;
  
           delete $SIG_CB{$signal}{$cb};
  
           $HAVE_ASYNC_INTERRUPT
              ? delete $SIG_ASY{$signal}
              : # delete doesn't work with older perls - they then
                # print weird messages, or just unconditionally exit
                # instead of getting the default action.
                undef $SIG{$signal}
              unless keys %{ $SIG_CB{$signal} };
        };
  
        *_signal_exec = sub {
           $HAVE_ASYNC_INTERRUPT
              ? $SIGPIPE_R->drain
              : sysread $SIGPIPE_R, (my $dummy), 9;
  
           while (%SIG_EV) {
              for (keys %SIG_EV) {
                 delete $SIG_EV{$_};
                 &$_ for values %{ $SIG_CB{$_} || {} };
              }
           }
        };
     };die if $@;&signal}our%PID_CB;our$CHLD_W;our$CHLD_DELAY_W;sub _emit_childstatus($$) {my (undef,$rpid,$rstatus)=@_;$_->($rpid,$rstatus)for values %{$PID_CB{$rpid}|| {}},values %{$PID_CB{0}|| {}}}sub child {eval q{ # poor man's autoloading {}
        *_sigchld = sub {
           my $pid;
  
           AnyEvent->_emit_childstatus ($pid, $?)
              while ($pid = waitpid -1, WNOHANG) > 0;
        };
  
        *child = sub {
           my (undef, %arg) = @_;
  
           my $pid = $arg{pid};
           my $cb  = $arg{cb};
  
           $PID_CB{$pid}{$cb+0} = $cb;
  
           unless ($CHLD_W) {
              $CHLD_W = AE::signal CHLD => \&_sigchld;
              # child could be a zombie already, so make at least one round
              &_sigchld;
           }
  
           bless [$pid, $cb+0], "AnyEvent::Base::child"
        };
  
        *AnyEvent::Base::child::DESTROY = sub {
           my ($pid, $icb) = @{$_[0]};
  
           delete $PID_CB{$pid}{$icb};
           delete $PID_CB{$pid} unless keys %{ $PID_CB{$pid} };
  
           undef $CHLD_W unless keys %PID_CB;
        };
     };die if $@;&child}sub idle {eval q{ # poor man's autoloading {}
        *idle = sub {
           my (undef, %arg) = @_;
  
           my ($cb, $w, $rcb) = $arg{cb};
  
           $rcb = sub {
              if ($cb) {
                 $w = AE::time;
                 &$cb;
                 $w = AE::time - $w;
  
                 # never use more then 50% of the time for the idle watcher,
                 # within some limits
                 $w = 0.0001 if $w < 0.0001;
                 $w = 5      if $w > 5;
  
                 $w = AE::timer $w, 0, $rcb;
              } else {
                 # clean up...
                 undef $w;
                 undef $rcb;
              }
           };
  
           $w = AE::timer 0.05, 0, $rcb;
  
           bless \\$cb, "AnyEvent::Base::idle"
        };
  
        *AnyEvent::Base::idle::DESTROY = sub {
           undef $${$_[0]};
        };
     };die if $@;&idle}package AnyEvent::CondVar;our@ISA=AnyEvent::CondVar::Base::;sub new {my$class=shift;bless AnyEvent->condvar (@_),$class}package AnyEvent::CondVar::Base;${"AnyEvent::CondVar::Base::OVERLOAD"}{dummy}++;*{'AnyEvent::CondVar::Base::()'}=sub {};*{'AnyEvent::CondVar::Base::(&{}'}=sub {my$self=shift;sub {$self->send (@_)}};${'AnyEvent::CondVar::Base::()'}=1;our$WAITING;sub _send {}sub _wait {AnyEvent->_poll until $_[0]{_ae_sent}}sub send {my$cv=shift;$cv->{_ae_sent}=[@_];(delete$cv->{_ae_cb})->($cv)if$cv->{_ae_cb};$cv->_send}sub croak {$_[0]{_ae_croak}=$_[1];$_[0]->send}sub ready {$_[0]{_ae_sent}}sub recv {unless ($_[0]{_ae_sent}){$WAITING and Carp::croak "AnyEvent::CondVar: recursive blocking wait attempted";local$WAITING=1;$_[0]->_wait}$_[0]{_ae_croak}and Carp::croak $_[0]{_ae_croak};wantarray ? @{$_[0]{_ae_sent}}: $_[0]{_ae_sent}[0]}sub cb {my$cv=shift;@_ and $cv->{_ae_cb}=shift and $cv->{_ae_sent}and (delete$cv->{_ae_cb})->($cv);$cv->{_ae_cb}}sub begin {++$_[0]{_ae_counter};$_[0]{_ae_end_cb}=$_[1]if @_ > 1}sub end {return if --$_[0]{_ae_counter};&{$_[0]{_ae_end_cb}|| sub {$_[0]->send}}}*broadcast=\&send;*wait=\&recv;undef$SIG{CHLD}if$SIG{CHLD}eq 'IGNORE';$SIG{PIPE}=sub {}unless defined$SIG{PIPE};1
ANYEVENT

$fatpacked{"AnyEvent/DNS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_DNS';
  package AnyEvent::DNS;use Carp ();use Socket qw(AF_INET SOCK_DGRAM SOCK_STREAM);use AnyEvent ();BEGIN {AnyEvent::common_sense}use AnyEvent::Util qw(AF_INET6);our$VERSION=$AnyEvent::VERSION;our@DNS_FALLBACK;{my$prep=sub {$_=$_->[rand @$_]for @_;push @_,splice @_,rand $_,1 for reverse 1..@_;$_=pack "H*",$_ for @_;\@_};my$ipv4=$prep->(["08080808","08080404"],);my$ipv6=$prep->(["20014860486000000000000000008888","20014860486000000000000000008844"],);undef$ipv4 unless$AnyEvent::PROTOCOL{ipv4};undef$ipv6 unless$AnyEvent::PROTOCOL{ipv6};($ipv6,$ipv4)=($ipv4,$ipv6)if$AnyEvent::PROTOCOL{ipv6}> $AnyEvent::PROTOCOL{ipv4};@DNS_FALLBACK=(@$ipv4,@$ipv6)}sub MAX_PKT() {4096}sub DOMAIN_PORT() {53}sub resolver ();sub a($$) {my ($domain,$cb)=@_;resolver->resolve ($domain=>"a",sub {$cb->(map $_->[4],@_)})}sub aaaa($$) {my ($domain,$cb)=@_;resolver->resolve ($domain=>"aaaa",sub {$cb->(map $_->[4],@_)})}sub mx($$) {my ($domain,$cb)=@_;resolver->resolve ($domain=>"mx",sub {$cb->(map $_->[5],sort {$a->[4]<=> $b->[4]}@_)})}sub ns($$) {my ($domain,$cb)=@_;resolver->resolve ($domain=>"ns",sub {$cb->(map $_->[4],@_)})}sub txt($$) {my ($domain,$cb)=@_;resolver->resolve ($domain=>"txt",sub {$cb->(map $_->[4],@_)})}sub srv($$$$) {my ($service,$proto,$domain,$cb)=@_;resolver->resolve ("_$service._$proto.$domain"=>"srv",sub {my@res;my%pri;push @{$pri{$_->[4]}},[@$_[4,5,6,7]]for @_;for my$pri (sort {$a <=> $b}keys%pri){my@rr=sort {$a->[1]<=> $b->[1]}@{delete$pri{$pri}};my$sum;$sum += $_->[1]for@rr;while (@rr){my$w=int rand$sum + 1;for (0 .. $#rr){if (($w -= $rr[$_][1])<= 0){$sum -= $rr[$_][1];push@res,splice@rr,$_,1,();last}}}}$cb->(@res)})}sub ptr($$) {my ($domain,$cb)=@_;resolver->resolve ($domain=>"ptr",sub {$cb->(map $_->[4],@_)})}sub any($$) {my ($domain,$cb)=@_;resolver->resolve ($domain=>"*",$cb)}sub _munge_ptr($) {my$ipn=$_[0]or return;my$ptr;my$af=AnyEvent::Socket::address_family ($ipn);if ($af==AF_INET6){$ipn=substr$ipn,0,16;if ($ipn =~ s/^\x00{10}(?:\xff\xff|\x00\x00)//){$af=AF_INET}else {$ptr=join ".",(reverse split //,unpack "H32",$ipn),"ip6.arpa."}}if ($af==AF_INET){$ptr=join ".",(reverse unpack "C4",$ipn),"in-addr.arpa."}$ptr}sub reverse_lookup($$) {my ($ip,$cb)=@_;$ip=_munge_ptr AnyEvent::Socket::parse_address ($ip)or return$cb->();resolver->resolve ($ip=>"ptr",sub {$cb->(map $_->[4],@_)})}sub reverse_verify($$) {my ($ip,$cb)=@_;my$ipn=AnyEvent::Socket::parse_address ($ip)or return$cb->();my$af=AnyEvent::Socket::address_family ($ipn);my@res;my$cnt;my$ptr=_munge_ptr$ipn or return$cb->();$ip=AnyEvent::Socket::format_address ($ipn);ptr$ptr,sub {for my$name (@_){++$cnt;resolver->resolve ("$name."=>($af==(AF_INET)? "a" : "aaaa"),sub {for (@_){push@res,$name if $_->[4]eq $ip}$cb->(@res)unless --$cnt})}$cb->()unless$cnt}}our$EDNS0=$ENV{PERL_ANYEVENT_EDNS0}*1;our%opcode_id=(query=>0,iquery=>1,status=>2,notify=>4,update=>5,map +($_=>$_),3,6..15);our%opcode_str=reverse%opcode_id;our%rcode_id=(noerror=>0,formerr=>1,servfail=>2,nxdomain=>3,notimp=>4,refused=>5,yxdomain=>6,yxrrset=>7,nxrrset=>8,notauth=>9,notzone=>10,map +($_=>$_),11..15);our%rcode_str=reverse%rcode_id;our%type_id=(a=>1,ns=>2,md=>3,mf=>4,cname=>5,soa=>6,mb=>7,mg=>8,mr=>9,null=>10,wks=>11,ptr=>12,hinfo=>13,minfo=>14,mx=>15,txt=>16,aaaa=>28,srv=>33,naptr=>35,dname=>39,opt=>41,spf=>99,tkey=>249,tsig=>250,ixfr=>251,axfr=>252,mailb=>253,"*"=>255,);our%type_str=reverse%type_id;our%class_id=(in=>1,ch=>3,hs=>4,none=>254,"*"=>255,);our%class_str=reverse%class_id;sub _enc_name($) {pack "(C/a*)*",(split /\./,shift),""}if ($] < 5.008){*_enc_name=sub ($) {join "",map +(pack "C/a*",$_),(split /\./,shift),""}}sub _enc_qd() {(_enc_name $_->[0]).pack "nn",($_->[1]> 0 ? $_->[1]: $type_id {$_->[1]}),($_->[3]> 0 ? $_->[2]: $class_id{$_->[2]|| "in"})}sub _enc_rr() {die "encoding of resource records is not supported"}sub dns_pack($) {my ($req)=@_;pack "nn nnnn a* a* a* a* a*",$req->{id},!!$req->{qr}* 0x8000 + $opcode_id{$req->{op}}* 0x0800 +!!$req->{aa}* 0x0400 +!!$req->{tc}* 0x0200 +!!$req->{rd}* 0x0100 +!!$req->{ra}* 0x0080 +!!$req->{ad}* 0x0020 +!!$req->{cd}* 0x0010 + $rcode_id{$req->{rc}}* 0x0001,scalar @{$req->{qd}|| []},scalar @{$req->{an}|| []},scalar @{$req->{ns}|| []},$EDNS0 + scalar @{$req->{ar}|| []},(join "",map _enc_qd,@{$req->{qd}|| []}),(join "",map _enc_rr,@{$req->{an}|| []}),(join "",map _enc_rr,@{$req->{ns}|| []}),(join "",map _enc_rr,@{$req->{ar}|| []}),($EDNS0 ? pack "C nnNn",0,41,MAX_PKT,0,0 : "")}our$ofs;our$pkt;sub _dec_name {my@res;my$redir;my$ptr=$ofs;my$cnt;while (){return undef if ++$cnt >= 256;my$len=ord substr$pkt,$ptr++,1;if ($len >= 0xc0){$ptr++;$ofs=$ptr if$ptr > $ofs;$ptr=(unpack "n",substr$pkt,$ptr - 2,2)& 0x3fff}elsif ($len){push@res,substr$pkt,$ptr,$len;$ptr += $len}else {$ofs=$ptr if$ptr > $ofs;return join ".",@res}}}sub _dec_qd {my$qname=_dec_name;my ($qt,$qc)=unpack "nn",substr$pkt,$ofs;$ofs += 4;[$qname,$type_str{$qt}|| $qt,$class_str{$qc}|| $qc]}our%dec_rr=(1=>sub {join ".",unpack "C4",$_},2=>sub {local$ofs=$ofs - length;_dec_name},5=>sub {local$ofs=$ofs - length;_dec_name},6=>sub {local$ofs=$ofs - length;my$mname=_dec_name;my$rname=_dec_name;($mname,$rname,unpack "NNNNN",substr$pkt,$ofs)},11=>sub {((join ".",unpack "C4",$_),unpack "C a*",substr $_,4)},12=>sub {local$ofs=$ofs - length;_dec_name},13=>sub {unpack "C/a* C/a*",$_},15=>sub {local$ofs=$ofs + 2 - length;((unpack "n",$_),_dec_name)},16=>sub {unpack "(C/a*)*",$_},28=>sub {AnyEvent::Socket::format_ipv6 ($_)},33=>sub {local$ofs=$ofs + 6 - length;((unpack "nnn",$_),_dec_name)},35=>sub {my ($order,$preference,$flags,$service,$regexp,$offset)=unpack "nn C/a* C/a* C/a* .",$_;local$ofs=$ofs + $offset - length;($order,$preference,$flags,$service,$regexp,_dec_name)},39=>sub {local$ofs=$ofs - length;_dec_name},99=>sub {unpack "(C/a*)*",$_},);sub _dec_rr {my$name=_dec_name;my ($rt,$rc,$ttl,$rdlen)=unpack "nn N n",substr$pkt,$ofs;$ofs += 10;local $_=substr$pkt,$ofs,$rdlen;$ofs += $rdlen;[$name,$type_str{$rt}|| $rt,$class_str{$rc}|| $rc,$ttl,($dec_rr{$rt}|| sub {$_})->(),]}sub dns_unpack($) {local$pkt=shift;my ($id,$flags,$qd,$an,$ns,$ar)=unpack "nn nnnn A*",$pkt;local$ofs=6 * 2;{id=>$id,qr=>!!($flags & 0x8000),aa=>!!($flags & 0x0400),tc=>!!($flags & 0x0200),rd=>!!($flags & 0x0100),ra=>!!($flags & 0x0080),ad=>!!($flags & 0x0020),cd=>!!($flags & 0x0010),op=>$opcode_str{($flags & 0x001e)>> 11},rc=>$rcode_str{($flags & 0x000f)},qd=>[map _dec_qd,1 .. $qd],an=>[map _dec_rr,1 .. $an],ns=>[map _dec_rr,1 .. $ns],ar=>[map _dec_rr,1 .. $ar],}}use Carp ();use Scalar::Util ();use Socket ();our$NOW;our$RESOLVER;sub resolver() {$RESOLVER || do {$RESOLVER=new AnyEvent::DNS untaint=>1,max_outstanding=>$ENV{PERL_ANYEVENT_MAX_OUTSTANDING_DNS}*1 || 10,;$ENV{PERL_ANYEVENT_RESOLV_CONF}? $RESOLVER->_load_resolv_conf_file ($ENV{PERL_ANYEVENT_RESOLV_CONF}): $RESOLVER->os_config;$RESOLVER}}sub new {my ($class,%arg)=@_;my$self=bless {server=>[],timeout=>[2,5,5],search=>[],ndots=>1,max_outstanding=>10,reuse=>300,%arg,inhibit=>0,reuse_q=>[],},$class;my$got_socket;Scalar::Util::weaken (my$wself=$self);if (socket my$fh4,AF_INET,Socket::SOCK_DGRAM(),0){++$got_socket;AnyEvent::fh_unblock$fh4;$self->{fh4}=$fh4;$self->{rw4}=AE::io$fh4,0,sub {if (my$peer=recv$fh4,my$pkt,MAX_PKT,0){$wself->_recv ($pkt,$peer)}}}if (AF_INET6 && socket my$fh6,AF_INET6,Socket::SOCK_DGRAM(),0){++$got_socket;$self->{fh6}=$fh6;AnyEvent::fh_unblock$fh6;$self->{rw6}=AE::io$fh6,0,sub {if (my$peer=recv$fh6,my$pkt,MAX_PKT,0){$wself->_recv ($pkt,$peer)}}}$got_socket or Carp::croak "unable to create either an IPv4 or an IPv6 socket";$self->_compile;$self}sub _config_begin {++$_[0]{inhibit}}sub _config_done {--$_[0]{inhibit};$_[0]->_compile;$_[0]->_scheduler}sub parse_resolv_conf {my ($self,$resolvconf)=@_;$self->{server}=[];$self->{search}=[];my$attempts;for (split /\n/,$resolvconf){s/\s*[;#].*$//;if (/^\s*nameserver\s+(\S+)\s*$/i){my$ip=$1;if (my$ipn=AnyEvent::Socket::parse_address ($ip)){push @{$self->{server}},$ipn}else {AE::log 5=>"nameserver $ip invalid and ignored, while parsing resolver config."}}elsif (/^\s*domain\s+(\S*)\s*$/i){$self->{search}=[$1]}elsif (/^\s*search\s+(.*?)\s*$/i){$self->{search}=[split /\s+/,$1]}elsif (/^\s*sortlist\s+(.*?)\s*$/i){}elsif (/^\s*options\s+(.*?)\s*$/i){for (split /\s+/,$1){if (/^timeout:(\d+)$/){$self->{timeout}=[$1]}elsif (/^attempts:(\d+)$/){$attempts=$1}elsif (/^ndots:(\d+)$/){$self->{ndots}=$1}else {}}}else {}}$self->{timeout}=[($self->{timeout}[0])x $attempts]if$attempts;$self->_compile}sub _load_resolv_conf_file {my ($self,$resolv_conf)=@_;$self->_config_begin;require AnyEvent::IO;AnyEvent::IO::aio_load ($resolv_conf,sub {if (my ($contents)=@_){$self->parse_resolv_conf ($contents)}else {AE::log 4=>"$resolv_conf: $!"}$self->_config_done})}sub os_config {my ($self)=@_;$self->_config_begin;$self->{server}=[];$self->{search}=[];if ((AnyEvent::WIN32 || $^O =~ /cygwin/i)){unless (eval {require Net::DNS::Resolver;my$r=Net::DNS::Resolver->new;$r->nameservers or die;for my$s ($r->nameservers){if (my$ipn=AnyEvent::Socket::parse_address ($s)){push @{$self->{server}},$ipn}}$self->{search}=[$r->searchlist];1}){if (open my$fh,"ipconfig /all |"){my$dns;local $_;while (<$fh>){if (s/^\s.*\bdns\b.*://i){$dns=1}elsif (/^\S/ || /^\s[^:]{16,}: /){$dns=0}if ($dns && /^\s*(\S+)\s*$/){my$s=$1;$s =~ s/%\d+(?!\S)//;if (my$ipn=AnyEvent::Socket::parse_address ($s)){push @{$self->{server}},$ipn}else {push @{$self->{search}},$s}}}}}push @{$self->{server}},@DNS_FALLBACK;$self->_config_done}else {require AnyEvent::IO;AnyEvent::IO::aio_stat ("/etc/resolv.conf",sub {$self->_load_resolv_conf_file ("/etc/resolv.conf")if @_;$self->_config_done})}}sub timeout {my ($self,@timeout)=@_;$self->{timeout}=\@timeout;$self->_compile}sub max_outstanding {my ($self,$max)=@_;$self->{max_outstanding}=$max;$self->_compile}sub _compile {my$self=shift;my%search;$self->{search}=[grep 0 < length,grep!$search{$_}++,@{$self->{search}}];my%server;$self->{server}=[grep 0 < length,grep!$server{$_}++,@{$self->{server}}];unless (@{$self->{server}}){my$default=$AnyEvent::PROTOCOL{ipv6}> $AnyEvent::PROTOCOL{ipv4}? "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1" : "\x7f\x00\x00\x01";$self->{server}=[$default,@DNS_FALLBACK]}my@retry;for my$timeout (@{$self->{timeout}}){for my$server (@{$self->{server}}){push@retry,[$server,$timeout]}}$self->{retry}=\@retry}sub _feed {my ($self,$res)=@_;($res)=$res =~ /^(.*)$/s if AnyEvent::TAINT && $self->{untaint};$res=dns_unpack$res or return;my$id=$self->{id}{$res->{id}};return unless ref$id;$NOW=time;$id->[1]->($res)}sub _recv {my ($self,$pkt,$peer)=@_;my ($port,$host)=AnyEvent::Socket::unpack_sockaddr ($peer);return unless$port==DOMAIN_PORT && grep $_ eq $host,@{$self->{server}};$self->_feed ($pkt)}sub _free_id {my ($self,$id,$timeout)=@_;if ($timeout){$self->{id}{$id}=1;push @{$self->{reuse_q}},[$NOW + $self->{reuse},$id]}else {delete$self->{id}{$id}}--$self->{outstanding};$self->_scheduler}sub _exec {my ($self,$req)=@_;my$retry;my$do_retry;$do_retry=sub {my$retry_cfg=$self->{retry}[$retry++]or do {$self->_free_id ($req->[2],$retry > 1);undef$do_retry;return$req->[1]->()};my ($server,$timeout)=@$retry_cfg;$self->{id}{$req->[2]}=[(AE::timer$timeout,0,sub {$NOW=time;&$do_retry if$do_retry}),sub {my ($res)=@_;if ($res->{tc}){AnyEvent::Socket::tcp_connect (AnyEvent::Socket::format_address ($server),DOMAIN_PORT,sub {return unless$do_retry;my ($fh)=@_ or return &$do_retry;require AnyEvent::Handle;my$handle;$handle=new AnyEvent::Handle fh=>$fh,timeout=>$timeout,on_error=>sub {undef$handle;return unless$do_retry;&$do_retry};$handle->push_write (pack "n/a*",$req->[0]);$handle->push_read (chunk=>2,sub {$handle->unshift_read (chunk=>(unpack "n",$_[1]),sub {undef$handle;$self->_feed ($_[1])})})},sub {$timeout})}else {$self->_free_id ($req->[2],$retry > 1);undef$do_retry;return$req->[1]->($res)}}];my$sa=AnyEvent::Socket::pack_sockaddr (DOMAIN_PORT,$server);my$fh=AF_INET==AnyEvent::Socket::sockaddr_family ($sa)? $self->{fh4}: $self->{fh6}or return &$do_retry;send$fh,$req->[0],0,$sa};&$do_retry}sub _scheduler {my ($self)=@_;return if$self->{inhibit};$NOW=time;delete$self->{id}{(shift @{$self->{reuse_q}})->[1]}while @{$self->{reuse_q}}&& $self->{reuse_q}[0][0]<= $NOW;while ($self->{outstanding}< $self->{max_outstanding}){if (@{$self->{reuse_q}}>= 30000){$self->{reuse_to}||= AE::timer$self->{reuse_q}[0][0]- $NOW,0,sub {delete$self->{reuse_to};$self->_scheduler};last}if (my$req=shift @{$self->{queue}}){while (){$req->[2]=int rand 65536;last unless exists$self->{id}{$req->[2]}}++$self->{outstanding};$self->{id}{$req->[2]}=1;substr$req->[0],0,2,pack "n",$req->[2];$self->_exec ($req)}elsif (my$cb=shift @{$self->{wait}}){$cb->($self)}else {last}}}sub request($$) {my ($self,$req,$cb)=@_;for (@{$req->{qd}}){return AE::postpone sub {$cb->(undef)}if 255 < length $_->[0]}push @{$self->{queue}},[dns_pack$req,$cb];$self->_scheduler}sub resolve($%) {my$cb=pop;my ($self,$qname,$qtype,%opt)=@_;$self->wait_for_slot (sub {my$self=shift;my@search=$qname =~ s/\.$// ? "" : $opt{search}? @{$opt{search}}: ($qname =~ y/.//)>= $self->{ndots}? ("",@{$self->{search}}): (@{$self->{search}},"");my$class=$opt{class}|| "in";my%atype=$opt{accept}? map +($_=>1),@{$opt{accept}}: ($qtype=>1);my ($do_search,$do_req);$do_search=sub {@search or (undef$do_search),(undef$do_req),return$cb->();(my$name=lc "$qname." .shift@search)=~ s/\.$//;my$depth=10;$do_req=sub {$self->request ({rd=>1,qd=>[[$name,$qtype,$class]],},sub {my ($res)=@_ or return$do_search->();my$cname;while (){my@rr=grep$name eq lc $_->[0]&& ($atype{"*"}|| $atype{$_->[1]}),@{$res->{an}};(undef$do_search),(undef$do_req),return$cb->(@rr)if@rr;my@rr=grep$name eq lc $_->[0]&& $_->[1]eq "cname",@{$res->{an}};if (@rr){$depth-- or return$do_search->();$cname=1;$name=lc$rr[0][4]}elsif ($cname){return$do_req->()}else {return$do_search->()}}})};$do_req->()};$do_search->()})}sub wait_for_slot {my ($self,$cb)=@_;push @{$self->{wait}},$cb;$self->_scheduler}use AnyEvent::Socket ();1
ANYEVENT_DNS

$fatpacked{"AnyEvent/Debug.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_DEBUG';
  package AnyEvent::Debug;use B ();use Carp ();use Errno ();use AnyEvent ();BEGIN {AnyEvent::common_sense}use AnyEvent::Util ();use AnyEvent::Socket ();use AnyEvent::Log ();our$TRACE=1;our ($TRACE_LOGGER,$TRACE_ENABLED);our%STRCACHE;sub shell($$) {local$TRACE=0;AnyEvent::Socket::tcp_server $_[0],$_[1],sub {my ($fh,$host,$port)=@_;syswrite$fh,"Welcome, $host:$port, use 'help' for more info!\015\012> ";my$rbuf;my$logger=new AnyEvent::Log::Ctx log_cb=>sub {syswrite$fh,shift;0};my$logger_guard=AnyEvent::Util::guard {$AnyEvent::Log::COLLECT->detach ($logger)};$AnyEvent::Log::COLLECT->attach ($logger);local$TRACE=0;my$rw;$rw=AE::io$fh,0,sub {my$len=sysread$fh,$rbuf,1024,length$rbuf;$logger_guard if 0;if (defined$len ? $len==0 : ($!!=Errno::EAGAIN && $!!=Errno::EWOULDBLOCK)){undef$rw}else {while ($rbuf =~ s/^(.*)\015?\012//){my$line=$1;AnyEvent::fh_block$fh;if ($line =~ /^\s*exit\b/){syswrite$fh,"sorry, no... if you want to execute exit, try CORE::exit.\015\012"}elsif ($line =~ /^\s*coro\b\s*(.*)/){my$arg=$1;if (eval {require Coro;require Coro::Debug}){if ($arg =~ /\S/){Coro::async (sub {select$fh;Coro::Debug::command ($arg);local $|=1;syswrite$fh,"> "});return}else {undef$rw;syswrite$fh,"switching to Coro::Debug...\015\012";Coro::async (sub {Coro::Debug::session ($fh)});return}}else {syswrite$fh,"Coro not available.\015\012"}}else {package AnyEvent::Debug::shell;no strict 'vars';local$LOGGER=$logger;my$old_stdout=select$fh;local $|=1;my@res=eval$line;select$old_stdout;syswrite$fh,"$@" if $@;syswrite$fh,"\015\012";if (@res > 1){syswrite$fh,"$_: $res[$_]\015\012" for 0 .. $#res}elsif (@res==1){syswrite$fh,"$res[0]\015\012"}}syswrite$fh,"> ";AnyEvent::fh_unblock$fh}}}}}{package AnyEvent::Debug::shell;our$LOGGER;sub help() {<<EOF}sub wl(;$) {my$re=@_ ? qr<$_[0]>i : qr<.>;my%res;while (my ($k,$v)=each%AnyEvent::Debug::Wrapped){my$s="$v";$res{$s}=$k .(exists$v->{error}? "*" : " ")if$s =~ $re}join "",map "$res{$_} $_\n",sort keys%res}sub w {map {$AnyEvent::Debug::Wrapped{$_}|| do {print "$_: no such wrapped watcher.\n";()}}@_}sub i {join "",map $_->id ." $_\n" .$_->verbose ."\n",&w}sub wr {AnyEvent::Debug::wrap (@_);"wrap level now $AnyEvent::Debug::WRAP_LEVEL"}sub t {if (@_){@_=&w;$_->trace (1)for @_;"tracing enabled for @_."}else {$AnyEvent::Debug::TRACE=1;"tracing for newly created watchers is now enabled."}}sub u {if (@_){@_=&w;$_->trace (0)for @_;"tracing disabled for @_."}else {$AnyEvent::Debug::TRACE=0;"tracing for newly created watchers is now disabled."}}sub v {$LOGGER->level (@_ ? $_[0]: $LOGGER->[1]? 0 : 9);"verbose logging is now " .($LOGGER->[1]? "enabled" : "disabled")."."}}our$WRAP_LEVEL;our$TRACE_CUR;our$POST_DETECT;sub wrap(;$) {my$PREV_LEVEL=$WRAP_LEVEL;$WRAP_LEVEL=@_ ? 0+shift : $WRAP_LEVEL ? 0 : 1;if ($AnyEvent::MODEL){if ($WRAP_LEVEL &&!$PREV_LEVEL){$TRACE_LOGGER=AnyEvent::Log::logger trace=>\$TRACE_ENABLED;AnyEvent::_isa_hook 0=>"AnyEvent::Debug::Wrap",1;AnyEvent::Debug::Wrap::_reset ()}elsif (!$WRAP_LEVEL && $PREV_LEVEL){AnyEvent::_isa_hook 0=>undef}}else {$POST_DETECT ||= AnyEvent::post_detect {undef$POST_DETECT;return unless$WRAP_LEVEL;(my$level,$WRAP_LEVEL)=($WRAP_LEVEL,undef);require AnyEvent::Strict unless$AnyEvent::Strict::VERSION;AnyEvent::post_detect {wrap ($level)}}}}sub path2mod($) {keys%INC;while (my ($k,$v)=each%INC){if ($_[0]eq $v){$k =~ s%/%::%g if$k =~ s/\.pm$//;return$k}}my$path=shift;$path =~ s%^\./%%;$path}sub cb2str($) {my$cb=shift;"CODE" eq ref$cb or return "$cb";eval {my$cv=B::svref_2object ($cb);my$gv=$cv->GV or return "$cb";my$name=$gv->NAME;return (AnyEvent::Debug::path2mod$gv->FILE).":" .$gv->LINE if$name eq "__ANON__";$gv->STASH->NAME ."::" .$name}|| "$cb"}sub sv2str($) {if (ref $_[0]){if (ref $_[0]eq "CODE"){return "$_[0]=" .cb2str $_[0]}else {return "$_[0]"}}else {for ("\'$_[0]\'"){substr $_,$Carp::MaxArgLen,length,"'..." if length > $Carp::MaxArgLen;return $_}}}sub backtrace(;$) {my$w=shift;my (@bt,@c);my ($modlen,$sub);for (;;){package DB;@c=caller$w++ or last;package AnyEvent::Debug;if ($c[7]){$sub="require $c[6]"}elsif (defined$c[6]){$sub="eval \"\""}else {$sub=($c[4]? "" : "&").$c[3];$sub .= "(" .(join ",",map sv2str$DB::args[$_],0 .. (@DB::args < $Carp::MaxArgNums ? @DB::args : $Carp::MaxArgNums)- 1).")" if$c[4]}push@bt,[\($STRCACHE{$c[1]}||= $c[1]),$c[2],$sub]}@DB::args=();bless \@bt,"AnyEvent::Debug::Backtrace"}package AnyEvent::Debug::Wrap;use AnyEvent ();BEGIN {AnyEvent::common_sense}use Scalar::Util ();use Carp ();sub _reset {for my$name (qw(io timer signal child idle)){my$super="SUPER::$name";*$name=sub {my ($self,%arg)=@_;my$w;my$t=$TRACE;my ($pkg,$file,$line,$sub);$w=0;do {($pkg,$file,$line)=caller$w++}while$pkg =~ /^(?:AE|AnyEvent::(?:Socket|Handle|Util|Debug|Strict|Base|CondVar|CondVar::Base|Impl::.*)|Coro::AnyEvent::CondVar)$/;$sub=(caller$w)[3];my$cb=$arg{cb};$arg{cb}=sub {++$w->{called};local$TRACE_CUR=$w;$TRACE_LOGGER->("enter $w")if$TRACE_ENABLED && $t;eval {local$SIG{__DIE__}=sub {die $_[0].AnyEvent::Debug::backtrace if defined $^S};&$cb};if ($@){my$err="$@";push @{$w->{error}},[AE::now,$err]if @{$w->{error}}< 10;AE::log die=>"($w) $err" or warn "($w) $err"}$TRACE_LOGGER->("leave $w")if$TRACE_ENABLED && $t};$self=bless {type=>$name,w=>$self->$super (%arg),rfile=>\($STRCACHE{$file}||= $file),line=>$line,sub=>$sub,cur=>"$TRACE_CUR",now=>AE::now,arg=>\%arg,cb=>$cb,called=>0,rt=>\$t,},"AnyEvent::Debug::Wrapped";delete$arg{cb};$self->{bt}=AnyEvent::Debug::backtrace 1 if$WRAP_LEVEL >= 2;Scalar::Util::weaken ($w=$self);Scalar::Util::weaken ($AnyEvent::Debug::Wrapped{Scalar::Util::refaddr$self}=$self);$TRACE_LOGGER->("creat $w")if$TRACE_ENABLED && $t;$self}}}package AnyEvent::Debug::Wrapped;use AnyEvent ();BEGIN {AnyEvent::common_sense}use overload '""'=>sub {$_[0]{str}||= do {my ($pkg,$line)=@{$_[0]{caller}};my$mod=AnyEvent::Debug::path2mod ${$_[0]{rfile}};my$sub=$_[0]{sub};if (defined$sub){$sub =~ s/^\Q$mod\E:://;$sub="($sub)"}"$mod:$_[0]{line}$sub>$_[0]{type}>" .(AnyEvent::Debug::cb2str $_[0]{cb})}},fallback=>1,;sub id {Scalar::Util::refaddr shift}sub verbose {my ($self)=@_;my$res="type:    $self->{type} watcher\n" ."args:    " .(join " ",%{$self->{arg}})."\n" ."created: " .(AnyEvent::Log::format_time$self->{now})." ($self->{now})\n" ."file:    ${ $self->{rfile} }\n" ."line:    $self->{line}\n" ."subname: $self->{sub}\n" ."context: $self->{cur}\n" ."tracing: " .(${$self->{rt}}? "enabled" : "disabled")."\n" ."cb:      $self->{cb} (" .(AnyEvent::Debug::cb2str$self->{cb}).")\n" ."invoked: $self->{called} times\n";if (exists$self->{bt}){$res .= "created\n$self->{bt}"}if (exists$self->{error}){$res .= "errors:   " .@{$self->{error}}."\n";$res .= "error: " .(AnyEvent::Log::format_time $_->[0])." ($_->[0]) $_->[1]\n" for @{$self->{error}}}$res}sub trace {${$_[0]{rt}}=$_[1]}sub DESTROY {$TRACE_LOGGER->("dstry $_[0]")if$TRACE_ENABLED && ${$_[0]{rt}};delete$AnyEvent::Debug::Wrapped{Scalar::Util::refaddr $_[0]}}package AnyEvent::Debug::Backtrace;use AnyEvent ();BEGIN {AnyEvent::common_sense}sub as_string {my ($self)=@_;my@bt;my$modlen;for (@$self){my ($rpath,$line,$sub)=@$_;$rpath=(AnyEvent::Debug::path2mod $$rpath)." line $line";$modlen=length$rpath if$modlen < length$rpath;$sub =~ s/\r/\\r/g;$sub =~ s/\n/\\n/g;$sub =~ s/([\x00-\x1f\x7e-\xff])/sprintf "\\x%02x", ord $1/ge;$sub =~ s/([^\x20-\x7e])/sprintf "\\x{%x}", ord $1/ge;push@bt,[$rpath,$sub]}join "",map {sprintf "%*s %s\n",-$modlen,$_->[0],$_->[1]}@bt}use overload '""'=>\&as_string,fallback=>1,;1
  help         this command
  wr [level]   sets wrap level to level (or toggles if missing)
  v [level]    sets verbosity (or toggles between 0 and 9 if missing)
  wl 'regex'   print wrapped watchers matching the regex (or all if missing)
  i id,...     prints the watcher with the given ids in more detail
  t            enable tracing for newly created watchers (enabled by default)
  ut           disable tracing for newly created watchers
  t  id,...    enable tracing for the given watcher (enabled by default)
  ut id,...    disable tracing for the given watcher
  w id,...     converts the watcher ids to watcher objects (for scripting)
  coro xxx     run xxx as Coro::Debug shell command, if available
  coro         switch to Coro::Debug shell, if available
  EOF
ANYEVENT_DEBUG

$fatpacked{"AnyEvent/Handle.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_HANDLE';
  package AnyEvent::Handle;use Scalar::Util ();use List::Util ();use Carp ();use Errno qw(EAGAIN EWOULDBLOCK EINTR);use AnyEvent ();BEGIN {AnyEvent::common_sense}use AnyEvent::Util qw(WSAEWOULDBLOCK);our$VERSION=$AnyEvent::VERSION;sub _load_func($) {my$func=$_[0];unless (defined &$func){my$pkg=$func;do {$pkg =~ s/::[^:]+$// or return;eval "require $pkg"}until defined &$func}\&$func}sub MAX_READ_SIZE() {131072}sub new {my$class=shift;my$self=bless {@_ },$class;if ($self->{fh}){$self->_start;return unless$self->{fh}}elsif ($self->{connect}){require AnyEvent::Socket;$self->{peername}=$self->{connect}[0]unless exists$self->{peername};$self->{_skip_drain_rbuf}=1;{Scalar::Util::weaken (my$self=$self);$self->{_connect}=AnyEvent::Socket::tcp_connect ($self->{connect}[0],$self->{connect}[1],sub {my ($fh,$host,$port,$retry)=@_;delete$self->{_connect};if ($fh){$self->{fh}=$fh;delete$self->{_skip_drain_rbuf};$self->_start;$self->{on_connect}and $self->{on_connect}($self,$host,$port,sub {delete @$self{qw(fh _tw _rtw _wtw _ww _rw _eof _queue rbuf _wbuf tls _tls_rbuf _tls_wbuf)};$self->{_skip_drain_rbuf}=1;&$retry})}else {if ($self->{on_connect_error}){$self->{on_connect_error}($self,"$!");$self->destroy if$self}else {$self->_error ($!,1)}}},sub {local$self->{fh}=$_[0];$self->{on_prepare}? $self->{on_prepare}->($self): ()})}}else {Carp::croak "AnyEvent::Handle: either an existing fh or the connect parameter must be specified"}$self}sub _start {my ($self)=@_;my$type=getsockopt$self->{fh},Socket::SOL_SOCKET (),Socket::SO_TYPE ();Carp::croak "AnyEvent::Handle: only stream sockets supported, anything else will NOT work!" if Socket::SOCK_STREAM ()!=(unpack "I",$type)&& defined$type;AnyEvent::fh_unblock$self->{fh};$self->{_activity}=$self->{_ractivity}=$self->{_wactivity}=AE::now;$self->{read_size}||= 2048;$self->{max_read_size}=$self->{read_size}if$self->{read_size}> ($self->{max_read_size}|| MAX_READ_SIZE);$self->timeout (delete$self->{timeout})if$self->{timeout};$self->rtimeout (delete$self->{rtimeout})if$self->{rtimeout};$self->wtimeout (delete$self->{wtimeout})if$self->{wtimeout};$self->no_delay (delete$self->{no_delay})if exists$self->{no_delay}&& $self->{no_delay};$self->keepalive (delete$self->{keepalive})if exists$self->{keepalive}&& $self->{keepalive};$self->oobinline (exists$self->{oobinline}? delete$self->{oobinline}: 1);$self->starttls (delete$self->{tls},delete$self->{tls_ctx})if$self->{tls};$self->on_drain (delete$self->{on_drain})if$self->{on_drain};$self->start_read if$self->{on_read}|| @{$self->{_queue}};$self->_drain_wbuf}sub _error {my ($self,$errno,$fatal,$message)=@_;$!=$errno;$message ||= "$!";if ($self->{on_error}){$self->{on_error}($self,$fatal,$message);$self->destroy if$fatal}elsif ($self->{fh}|| $self->{connect}){$self->destroy;Carp::croak "AnyEvent::Handle uncaught error: $message"}}sub fh {$_[0]{fh}}sub on_error {$_[0]{on_error}=$_[1]}sub on_eof {$_[0]{on_eof}=$_[1]}sub autocork {$_[0]{autocork}=$_[1]}sub no_delay {$_[0]{no_delay}=$_[1];setsockopt $_[0]{fh},Socket::IPPROTO_TCP (),Socket::TCP_NODELAY (),int $_[1]if $_[0]{fh}}sub keepalive {$_[0]{keepalive}=$_[1];eval {local$SIG{__DIE__};setsockopt $_[0]{fh},Socket::SOL_SOCKET (),Socket::SO_KEEPALIVE (),int $_[1]if $_[0]{fh}}}sub oobinline {$_[0]{oobinline}=$_[1];eval {local$SIG{__DIE__};setsockopt $_[0]{fh},Socket::SOL_SOCKET (),Socket::SO_OOBINLINE (),int $_[1]if $_[0]{fh}}}sub keepalive {$_[0]{keepalive}=$_[1];eval {local$SIG{__DIE__};setsockopt $_[0]{fh},Socket::SOL_SOCKET (),Socket::SO_KEEPALIVE (),int $_[1]if $_[0]{fh}}}sub on_starttls {$_[0]{on_starttls}=$_[1]}sub on_stoptls {$_[0]{on_stoptls}=$_[1]}sub rbuf_max {$_[0]{rbuf_max}=$_[1]}sub wbuf_max {$_[0]{wbuf_max}=$_[1]}for my$dir ("","r","w"){my$timeout="${dir}timeout";my$tw="_${dir}tw";my$on_timeout="on_${dir}timeout";my$activity="_${dir}activity";my$cb;*$on_timeout=sub {$_[0]{$on_timeout}=$_[1]};*$timeout=sub {my ($self,$new_value)=@_;$new_value >= 0 or Carp::croak "AnyEvent::Handle->$timeout called with negative timeout ($new_value), caught";$self->{$timeout}=$new_value;delete$self->{$tw};&$cb};*{"${dir}timeout_reset"}=sub {$_[0]{$activity}=AE::now};$cb=sub {my ($self)=@_;if ($self->{$timeout}&& $self->{fh}){my$NOW=AE::now;my$after=$self->{$activity}+ $self->{$timeout}- $NOW;if ($after <= 0){$self->{$activity}=$NOW;if ($self->{$on_timeout}){$self->{$on_timeout}($self)}else {$self->_error (Errno::ETIMEDOUT)}return unless$self->{$timeout};$after=$self->{$timeout}}Scalar::Util::weaken$self;return unless$self;$self->{$tw}||= AE::timer$after,0,sub {delete$self->{$tw};$cb->($self)}}else {delete$self->{$tw}}}}sub on_drain {my ($self,$cb)=@_;$self->{on_drain}=$cb;$cb->($self)if$cb && $self->{low_water_mark}>= (length$self->{wbuf})+ (length$self->{_tls_wbuf})}sub _drain_wbuf {my ($self)=@_;if (!$self->{_ww}&& length$self->{wbuf}){Scalar::Util::weaken$self;my$cb=sub {my$len=syswrite$self->{fh},$self->{wbuf};if (defined$len){substr$self->{wbuf},0,$len,"";$self->{_activity}=$self->{_wactivity}=AE::now;$self->{on_drain}($self)if$self->{low_water_mark}>= (length$self->{wbuf})+ (length$self->{_tls_wbuf})&& $self->{on_drain};delete$self->{_ww}unless length$self->{wbuf}}elsif ($!!=EAGAIN && $!!=EINTR && $!!=EWOULDBLOCK && $!!=WSAEWOULDBLOCK){$self->_error ($!,1)}};$cb->()unless$self->{autocork};$self->{_ww}=AE::io$self->{fh},1,$cb if length$self->{wbuf};if (defined$self->{wbuf_max}&& $self->{wbuf_max}< length$self->{wbuf}){$self->_error (Errno::ENOSPC,1),return}}}our%WH;sub register_write_type($$) {$WH{$_[0]}=$_[1]}sub push_write {my$self=shift;if (@_ > 1){my$type=shift;@_=($WH{$type}||= _load_func "$type\::anyevent_write_type" or Carp::croak "unsupported/unloadable type '$type' passed to AnyEvent::Handle::push_write")->($self,@_)}if ($self->{tls}){utf8::downgrade$self->{_tls_wbuf}.= $_[0];&_dotls ($self)if$self->{fh}}else {utf8::downgrade$self->{wbuf}.= $_[0];$self->_drain_wbuf if$self->{fh}}}register_write_type netstring=>sub {my ($self,$string)=@_;(length$string).":$string,"};register_write_type packstring=>sub {my ($self,$format,$string)=@_;pack "$format/a*",$string};sub json_coder() {eval {require JSON::XS;JSON::XS->new->utf8}|| do {require JSON::PP;JSON::PP->new->utf8}}register_write_type json=>sub {my ($self,$ref)=@_;($self->{json}||= json_coder)->encode ($ref)};sub cbor_coder() {require CBOR::XS;CBOR::XS->new}register_write_type cbor=>sub {my ($self,$scalar)=@_;($self->{cbor}||= cbor_coder)->encode ($scalar)};register_write_type storable=>sub {my ($self,$ref)=@_;require Storable unless$Storable::VERSION;pack "w/a*",Storable::nfreeze ($ref)};sub push_shutdown {my ($self)=@_;delete$self->{low_water_mark};$self->on_drain (sub {shutdown $_[0]{fh},1})}sub _drain_rbuf {my ($self)=@_;return if$self->{_skip_drain_rbuf};local$self->{_skip_drain_rbuf}=1;while (){$self->{rbuf}.= delete$self->{_tls_rbuf}if exists$self->{_tls_rbuf};my$len=length$self->{rbuf};if (my$cb=shift @{$self->{_queue}}){unless ($cb->($self)){$self->_error (Errno::EPIPE,1),return if$self->{_eof};unshift @{$self->{_queue}},$cb;last}}elsif ($self->{on_read}){last unless$len;$self->{on_read}($self);if ($len==length$self->{rbuf}&&!@{$self->{_queue}}&& $self->{on_read}){$self->_error (Errno::EPIPE,1),return if$self->{_eof};last}}else {delete$self->{_rw}unless$self->{tls};last}}if ($self->{_eof}){$self->{on_eof}? $self->{on_eof}($self): $self->_error (0,1,"Unexpected end-of-file");return}if (defined$self->{rbuf_max}&& $self->{rbuf_max}< length$self->{rbuf}){$self->_error (Errno::ENOSPC,1),return}unless ($self->{_rw}){$self->start_read if$self->{on_read}|| @{$self->{_queue}}}}sub on_read {my ($self,$cb)=@_;$self->{on_read}=$cb;$self->_drain_rbuf if$cb}sub rbuf : lvalue {$_[0]{rbuf}}our%RH;sub register_read_type($$) {$RH{$_[0]}=$_[1]}sub push_read {my$self=shift;my$cb=pop;if (@_){my$type=shift;$cb=($RH{$type}||= _load_func "$type\::anyevent_read_type" or Carp::croak "unsupported/unloadable type '$type' passed to AnyEvent::Handle::push_read")->($self,$cb,@_)}push @{$self->{_queue}},$cb;$self->_drain_rbuf}sub unshift_read {my$self=shift;my$cb=pop;if (@_){my$type=shift;$cb=($RH{$type}||= _load_func "$type\::anyevent_read_type" or Carp::croak "unsupported/unloadable type '$type' passed to AnyEvent::Handle::unshift_read")->($self,$cb,@_)}unshift @{$self->{_queue}},$cb;$self->_drain_rbuf}register_read_type chunk=>sub {my ($self,$cb,$len)=@_;sub {$len <= length $_[0]{rbuf}or return;$cb->($_[0],substr $_[0]{rbuf},0,$len,"");1}};register_read_type line=>sub {my ($self,$cb,$eol)=@_;if (@_ < 3){sub {(my$pos=index $_[0]{rbuf},"\012")>= 0 or return;(my$str=substr $_[0]{rbuf},0,$pos + 1,"")=~ s/(\015?\012)\Z// or die;$cb->($_[0],$str,"$1");1}}else {$eol=quotemeta$eol unless ref$eol;$eol=qr|^(.*?)($eol)|s;sub {$_[0]{rbuf}=~ s/$eol// or return;$cb->($_[0],"$1","$2");1}}};register_read_type regex=>sub {my ($self,$cb,$accept,$reject,$skip)=@_;my$data;my$rbuf=\$self->{rbuf};sub {if ($$rbuf =~ $accept){$data .= substr $$rbuf,0,$+[0],"";$cb->($_[0],$data);return 1}if ($reject && $$rbuf =~ $reject){$_[0]->_error (Errno::EBADMSG)}if ($skip && $$rbuf =~ $skip){$data .= substr $$rbuf,0,$+[0],""}()}};register_read_type netstring=>sub {my ($self,$cb)=@_;sub {unless ($_[0]{rbuf}=~ s/^(0|[1-9][0-9]*)://){if ($_[0]{rbuf}=~ /[^0-9]/){$_[0]->_error (Errno::EBADMSG)}return}my$len=$1;$_[0]->unshift_read (chunk=>$len,sub {my$string=$_[1];$_[0]->unshift_read (chunk=>1,sub {if ($_[1]eq ","){$cb->($_[0],$string)}else {$_[0]->_error (Errno::EBADMSG)}})});1}};register_read_type packstring=>sub {my ($self,$cb,$format)=@_;sub {defined (my$len=eval {unpack$format,$_[0]{rbuf}})or return;$format=length pack$format,$len;if ($format + $len <= length $_[0]{rbuf}){my$data=substr $_[0]{rbuf},$format,$len;substr $_[0]{rbuf},0,$format + $len,"";$cb->($_[0],$data)}else {substr $_[0]{rbuf},0,$format,"";$_[0]->unshift_read (chunk=>$len,$cb)}1}};register_read_type json=>sub {my ($self,$cb)=@_;my$json=$self->{json}||= json_coder;my$data;sub {my$ref=eval {$json->incr_parse ($_[0]{rbuf})};if ($ref){$_[0]{rbuf}=$json->incr_text;$json->incr_text="";$cb->($_[0],$ref);1}elsif ($@){$json->incr_skip;$_[0]{rbuf}=$json->incr_text;$json->incr_text="";$_[0]->_error (Errno::EBADMSG);()}else {$_[0]{rbuf}="";()}}};register_read_type cbor=>sub {my ($self,$cb)=@_;my$cbor=$self->{cbor}||= cbor_coder;my$data;sub {my (@value)=eval {$cbor->incr_parse ($_[0]{rbuf})};if (@value){$cb->($_[0],@value);1}elsif ($@){$cbor->incr_reset;$_[0]->_error (Errno::EBADMSG);()}else {()}}};register_read_type storable=>sub {my ($self,$cb)=@_;require Storable unless$Storable::VERSION;sub {defined (my$len=eval {unpack "w",$_[0]{rbuf}})or return;my$format=length pack "w",$len;if ($format + $len <= length $_[0]{rbuf}){my$data=substr $_[0]{rbuf},$format,$len;substr $_[0]{rbuf},0,$format + $len,"";eval {$cb->($_[0],Storable::thaw ($data));1}or return $_[0]->_error (Errno::EBADMSG)}else {substr $_[0]{rbuf},0,$format,"";$_[0]->unshift_read (chunk=>$len,sub {eval {$cb->($_[0],Storable::thaw ($_[1]));1}or $_[0]->_error (Errno::EBADMSG)})}1}};register_read_type tls_detect=>sub {my ($self,$cb)=@_;sub {if ($self->{rbuf}=~ /^(?:\z| \x16 (\z| [\x03\x04] (?:\z| . (?:\z| [\x00-\x40] ))))/xs or $self->{rbuf}=~ /^(?:\z| [\x80-\xff] (?:\z| . (?:\z| \x01 (\z| [\x03\x04] (?:\z| . (?:\z| . ))))))/xs){return if 3!=length $1;my ($major,$minor)=unpack "CC",$1;$cb->($self,"accept",$major + $minor * 0.1)}else {$cb->($self,undef)}1}};register_read_type tls_autostart=>sub {my ($self,@tls)=@_;$RH{tls_detect}($self,sub {return unless $_[1];$_[0]->starttls (@tls)})};sub stop_read {my ($self)=@_;delete$self->{_rw}}sub start_read {my ($self)=@_;unless ($self->{_rw}|| $self->{_eof}||!$self->{fh}){Scalar::Util::weaken$self;$self->{_rw}=AE::io$self->{fh},0,sub {my$rbuf=\($self->{tls}? my$buf : $self->{rbuf});my$len=sysread$self->{fh},$$rbuf,$self->{read_size},length $$rbuf;if ($len > 0){$self->{_activity}=$self->{_ractivity}=AE::now;if ($self->{tls}){Net::SSLeay::BIO_write ($self->{_rbio},$$rbuf);&_dotls ($self)}else {$self->_drain_rbuf}if ($len==$self->{read_size}){$self->{read_size}*= 2;$self->{read_size}=$self->{max_read_size}|| MAX_READ_SIZE if$self->{read_size}> ($self->{max_read_size}|| MAX_READ_SIZE)}}elsif (defined$len){delete$self->{_rw};$self->{_eof}=1;$self->_drain_rbuf}elsif ($!!=EAGAIN && $!!=EINTR && $!!=EWOULDBLOCK && $!!=WSAEWOULDBLOCK){return$self->_error ($!,1)}}}}our$ERROR_SYSCALL;our$ERROR_WANT_READ;sub _tls_error {my ($self,$err)=@_;return$self->_error ($!,1)if$err==Net::SSLeay::ERROR_SYSCALL ();my$err=Net::SSLeay::ERR_error_string (Net::SSLeay::ERR_get_error ());$err =~ s/^error:[0-9a-fA-F]{8}:[^:]+:([^:]+):/\L$1: /;if ($self->{_on_starttls}){(delete$self->{_on_starttls})->($self,undef,$err);&_freetls}else {&_freetls;$self->_error (Errno::EPROTO,1,$err)}}sub _dotls {my ($self)=@_;my$tmp;while (length$self->{_tls_wbuf}){if (($tmp=Net::SSLeay::write ($self->{tls},$self->{_tls_wbuf}))<= 0){$tmp=Net::SSLeay::get_error ($self->{tls},$tmp);return$self->_tls_error ($tmp)if$tmp!=$ERROR_WANT_READ && ($tmp!=$ERROR_SYSCALL || $!);last}substr$self->{_tls_wbuf},0,$tmp,""}while (defined ($tmp=Net::SSLeay::read ($self->{tls}))){unless (length$tmp){$self->{_on_starttls}and (delete$self->{_on_starttls})->($self,undef,"EOF during handshake");&_freetls;if ($self->{on_stoptls}){$self->{on_stoptls}($self);return}else {delete$self->{_rw};$self->{_eof}=1}}$self->{_tls_rbuf}.= $tmp;$self->_drain_rbuf;$self->{tls}or return}$tmp=Net::SSLeay::get_error ($self->{tls},-1);return$self->_tls_error ($tmp)if$tmp!=$ERROR_WANT_READ && ($tmp!=$ERROR_SYSCALL || $!);while (length ($tmp=Net::SSLeay::BIO_read ($self->{_wbio}))){$self->{wbuf}.= $tmp;$self->_drain_wbuf;$self->{tls}or return}$self->{_on_starttls}and Net::SSLeay::state ($self->{tls})==Net::SSLeay::ST_OK ()and (delete$self->{_on_starttls})->($self,1,"TLS/SSL connection established")}our%TLS_CACHE;sub starttls {my ($self,$tls,$ctx)=@_;Carp::croak "It is an error to call starttls on an AnyEvent::Handle object while TLS is already active, caught" if$self->{tls};unless (defined$AnyEvent::TLS::VERSION){eval {require Net::SSLeay;require AnyEvent::TLS;1}or return$self->_error (Errno::EPROTO,1,"TLS support not available on this system")}$self->{tls}=$tls;$self->{tls_ctx}=$ctx if @_ > 2;return unless$self->{fh};$ERROR_SYSCALL=Net::SSLeay::ERROR_SYSCALL ();$ERROR_WANT_READ=Net::SSLeay::ERROR_WANT_READ ();$tls=delete$self->{tls};$ctx=$self->{tls_ctx};local$Carp::CarpLevel=1;if ("HASH" eq ref$ctx){if ($ctx->{cache}){my$key=$ctx+0;$ctx=$TLS_CACHE{$key}||= new AnyEvent::TLS %$ctx}else {$ctx=new AnyEvent::TLS %$ctx}}$self->{tls_ctx}=$ctx || TLS_CTX ();$self->{tls}=$tls=$self->{tls_ctx}->_get_session ($tls,$self,$self->{peername});Net::SSLeay::CTX_set_mode ($tls,1|2);$self->{_rbio}=Net::SSLeay::BIO_new (Net::SSLeay::BIO_s_mem ());$self->{_wbio}=Net::SSLeay::BIO_new (Net::SSLeay::BIO_s_mem ());Net::SSLeay::BIO_write ($self->{_rbio},$self->{rbuf});$self->{rbuf}="";Net::SSLeay::set_bio ($tls,$self->{_rbio},$self->{_wbio});$self->{_on_starttls}=sub {$_[0]{on_starttls}(@_)}if$self->{on_starttls};&_dotls;$self->start_read}sub stoptls {my ($self)=@_;if ($self->{tls}&& $self->{fh}){Net::SSLeay::shutdown ($self->{tls});&_dotls}}sub _freetls {my ($self)=@_;return unless$self->{tls};$self->{tls_ctx}->_put_session (delete$self->{tls})if$self->{tls}> 0;delete @$self{qw(_rbio _wbio _tls_wbuf _on_starttls)}}*resettls=\&_freetls;sub DESTROY {my ($self)=@_;&_freetls;my$linger=exists$self->{linger}? $self->{linger}: 3600;if ($linger && length$self->{wbuf}&& $self->{fh}){my$fh=delete$self->{fh};my$wbuf=delete$self->{wbuf};my@linger;push@linger,AE::io$fh,1,sub {my$len=syswrite$fh,$wbuf,length$wbuf;if ($len > 0){substr$wbuf,0,$len,""}elsif (defined$len || ($!!=EAGAIN && $!!=EINTR && $!!=EWOULDBLOCK && $!!=WSAEWOULDBLOCK)){@linger=()}};push@linger,AE::timer$linger,0,sub {@linger=()}}}sub destroy {my ($self)=@_;$self->DESTROY;%$self=();bless$self,"AnyEvent::Handle::destroyed"}sub AnyEvent::Handle::destroyed::AUTOLOAD {}sub destroyed {0}sub AnyEvent::Handle::destroyed::destroyed {1}our$TLS_CTX;sub TLS_CTX() {$TLS_CTX ||= do {require AnyEvent::TLS;new AnyEvent::TLS}}1
ANYEVENT_HANDLE

$fatpacked{"AnyEvent/IO.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_IO';
  package AnyEvent::IO;use AnyEvent ();BEGIN {AnyEvent::common_sense}use base "Exporter";our@AIO_REQ=qw(aio_load aio_open aio_close aio_seek aio_read aio_write aio_truncate aio_utime aio_chown aio_chmod aio_stat aio_lstat aio_link aio_symlink aio_readlink aio_rename aio_unlink aio_mkdir aio_rmdir aio_readdir);*EXPORT=\@AIO_REQ;our@FLAGS=qw(O_RDONLY O_WRONLY O_RDWR O_CREAT O_EXCL O_TRUNC O_APPEND);*EXPORT_OK=\@FLAGS;our%EXPORT_TAGS=(flags=>\@FLAGS,aio=>\@AIO_REQ);our$MODEL;if ($MODEL){AE::log 7=>"Found preloaded IO model '$MODEL', using it."}else {if ($ENV{PERL_ANYEVENT_IO_MODEL}=~ /^([a-zA-Z0-9:]+)$/){if (eval {require "AnyEvent/IO/$ENV{PERL_ANYEVENT_IO_MODEL}.pm"}){AE::log 7=>"Loaded IO model '$MODEL' (forced by \$ENV{PERL_ANYEVENT_IO_MODEL}), using it."}else {undef$MODEL;AE::log 4=>"Unable to load IO model '$ENV{PERL_ANYEVENT_IO_MODEL}' (from \$ENV{PERL_ANYEVENT_IO_MODEL}):\n$@"}}unless ($MODEL){if (eval {require IO::AIO;require AnyEvent::AIO;require AnyEvent::IO::IOAIO}){AE::log 7=>"Autoloaded IO model 'IOAIO', using it."}else {require AnyEvent::IO::Perl;AE::log 7=>"Autoloaded IO model 'Perl', using it."}}}1
ANYEVENT_IO

$fatpacked{"AnyEvent/IO/IOAIO.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_IO_IOAIO';
  package AnyEvent::IO::IOAIO;use AnyEvent ();BEGIN {AnyEvent::common_sense}our$VERSION=$AnyEvent::VERSION;package AnyEvent::IO;use IO::AIO 4.13 ();use AnyEvent::AIO ();our$MODEL="AnyEvent::IO::IOAIO";sub aio_load($$) {my ($cb,$data)=$_[1];IO::AIO::aio_load $_[0],$data,sub {$cb->($_[0]>= 0 ? $data : ())}}sub aio_open($$$$) {my$cb=$_[3];IO::AIO::aio_open $_[0],$_[1],$_[2],sub {$cb->($_[0]or ())}}sub aio_close($$) {my$cb=$_[1];IO::AIO::aio_close $_[0],sub {$cb->($_[0]>= 0 ? 1 : ())}}sub aio_seek($$$$) {my ($cb)=$_[3];IO::AIO::aio_seek $_[0],$_[1],$_[2],sub {$cb->($_[0]>= 0 ? $_[0]: ())}}sub aio_read($$$) {my ($cb,$data)=$_[2];IO::AIO::aio_read $_[0],undef,$_[1],$data,0,sub {$cb->($_[0]>= 0 ? $data : ())}}sub aio_write($$$) {my$cb=$_[2];IO::AIO::aio_write $_[0],undef,(length $_[1]),$_[1],0,sub {$cb->($_[0]>= 0 ? $_[0]: ())}}sub aio_truncate($$$) {my$cb=$_[2];IO::AIO::aio_truncate $_[0],$_[1],sub {$cb->($_[0]? (): 1)}}sub aio_utime($$$$) {my$cb=$_[3];IO::AIO::aio_utime $_[0],$_[1],$_[2],sub {$cb->($_[0]? (): 1)}}sub aio_chown($$$$) {my$cb=$_[3];IO::AIO::aio_chown $_[0],$_[1],$_[2],sub {$cb->($_[0]? (): 1)}}sub aio_chmod($$$) {my$cb=$_[2];IO::AIO::aio_chmod $_[0],$_[1],sub {$cb->($_[0]? (): 1)}}sub aio_stat($$) {my$cb=$_[1];IO::AIO::aio_stat $_[0],sub {$cb->($_[0]? (): 1)}}sub aio_lstat($$) {my$cb=$_[1];IO::AIO::aio_lstat $_[0],sub {$cb->($_[0]? (): 1)}}sub aio_link($$$) {my$cb=$_[2];IO::AIO::aio_link $_[0],$_[1],sub {$cb->($_[0]? (): 1)}}sub aio_symlink($$$) {my$cb=$_[2];IO::AIO::aio_symlink $_[0],$_[1],sub {$cb->($_[0]? (): 1)}}sub aio_readlink($$) {my$cb=$_[1];IO::AIO::aio_readlink $_[0],sub {$cb->(defined $_[0]? $_[0]: ())}}sub aio_rename($$$) {my$cb=$_[2];IO::AIO::aio_rename $_[0],$_[1],sub {$cb->($_[0]? (): 1)}}sub aio_unlink($$) {my$cb=$_[1];IO::AIO::aio_unlink $_[0],sub {$cb->($_[0]? (): 1)}}sub aio_mkdir($$$) {my$cb=$_[2];IO::AIO::aio_mkdir $_[0],$_[1],sub {$cb->($_[0]? (): 1)}}sub aio_rmdir($$) {my$cb=$_[1];IO::AIO::aio_rmdir $_[0],sub {$cb->($_[0]? (): 1)}}sub aio_readdir($$) {my$cb=$_[1];IO::AIO::aio_readdirx $_[0],IO::AIO::READDIR_DIRS_FIRST | IO::AIO::READDIR_STAT_ORDER,sub {$cb->($_[0]or ())}}1
ANYEVENT_IO_IOAIO

$fatpacked{"AnyEvent/IO/Perl.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_IO_PERL';
  package AnyEvent::IO::Perl;use AnyEvent ();BEGIN {AnyEvent::common_sense}our$VERSION=$AnyEvent::VERSION;package AnyEvent::IO;our$MODEL="AnyEvent::IO::Perl";sub aio_load($$) {my ($path,$cb,$fh,$data)=@_;$cb->((open$fh,"<:raw:perlio",$path and stat$fh and (-s _)==sysread$fh,$data,-s _)? $data : ())}sub aio_open($$$$) {sysopen my$fh,$_[0],$_[1],$_[2]or return $_[3]();$_[3]($fh)}sub aio_close($$) {$_[1](close $_[0])}sub aio_seek($$$$) {my$data;$_[3](sysseek $_[0],$_[1],$_[2]or ())}sub aio_read($$$) {my$data;$_[2]((defined sysread $_[0],$data,$_[1])? $data : ())}sub aio_write($$$) {my$res=syswrite $_[0],$_[1];$_[2](defined$res ? $res : ())}sub aio_truncate($$$) {$_[2](truncate $_[0],$_[1]or ())}sub aio_utime($$$$) {$_[3](utime $_[1],$_[2],$_[0]or ())}sub aio_chown($$$$) {$_[3](chown defined $_[1]? $_[1]: -1,defined $_[2]? $_[2]: -1,$_[0]or ())}sub aio_chmod($$$) {$_[2](chmod $_[1],$_[0]or ())}sub aio_stat($$) {$_[1](stat $_[0])}sub aio_lstat($$) {$_[1](lstat $_[0])}sub aio_link($$$) {$_[2](link $_[0],$_[1]or ())}sub aio_symlink($$$) {$_[2](symlink $_[0],$_[1]or ())}sub aio_readlink($$) {my$res=readlink $_[0];$_[1](defined$res ? $res : ())}sub aio_rename($$$) {$_[2](rename $_[0],$_[1]or ())}sub aio_unlink($$) {$_[1](unlink $_[0]or ())}sub aio_mkdir($$$) {$_[2](mkdir $_[0],$_[1]or ())}sub aio_rmdir($$) {$_[1](rmdir $_[0]or ())}sub aio_readdir($$) {my ($fh,@res);opendir$fh,$_[0]or return $_[1]();@res=grep!/^\.\.?$/,readdir$fh;$_[1]((closedir$fh)? \@res : ())}1
ANYEVENT_IO_PERL

$fatpacked{"AnyEvent/IRC.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_IRC';
  package AnyEvent::IRC;use common::sense;use AnyEvent;our$VERSION='0.97';1;
ANYEVENT_IRC

$fatpacked{"AnyEvent/IRC/Client.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_IRC_CLIENT';
  package AnyEvent::IRC::Client;use common::sense;use Scalar::Util qw/weaken/;use Encode;use AnyEvent::Socket;use AnyEvent::Handle;use AnyEvent::IRC::Util qw/prefix_nick decode_ctcp split_prefix is_nick_prefix join_prefix encode_ctcp split_unicode_string mk_msg/;use base AnyEvent::IRC::Connection::;my%LOWER_CASEMAP=(rfc1459=>sub {tr/A-Z[]\\\^/a-z{}|~/},'strict-rfc1459'=>sub {tr/A-Z[]\\/a-z{}|/},ascii=>sub {tr/A-Z/a-z/},);sub new {my$this=shift;my$class=ref($this)|| $this;my$self=$class->SUPER::new (@_);$self->reg_cb (irc_001=>\&welcome_cb);$self->reg_cb (irc_376=>\&welcome_cb);$self->reg_cb (irc_422=>\&welcome_cb);$self->reg_cb (irc_005=>\&isupport_cb);$self->reg_cb (irc_join=>\&join_cb);$self->reg_cb (irc_nick=>\&nick_cb);$self->reg_cb (irc_part=>\&part_cb);$self->reg_cb (irc_kick=>\&kick_cb);$self->reg_cb (irc_quit=>\&quit_cb);$self->reg_cb (irc_mode=>\&mode_cb);$self->reg_cb (irc_353=>\&namereply_cb);$self->reg_cb (irc_366=>\&endofnames_cb);$self->reg_cb (irc_352=>\&whoreply_cb);$self->reg_cb (irc_311=>\&whoisuser_cb);$self->reg_cb (irc_305=>\&away_change_cb);$self->reg_cb (irc_306=>\&away_change_cb);$self->reg_cb (irc_ping=>\&ping_cb);$self->reg_cb (irc_pong=>\&pong_cb);$self->reg_cb (irc_privmsg=>\&privmsg_cb);$self->reg_cb (irc_notice=>\&privmsg_cb);$self->reg_cb ('irc_*'=>\&debug_cb);$self->reg_cb ('irc_*'=>\&anymsg_cb);$self->reg_cb ('irc_*'=>\&update_ident_cb);$self->reg_cb (disconnect=>\&disconnect_cb);$self->reg_cb (irc_332=>\&rpl_topic_cb);$self->reg_cb (irc_topic=>\&topic_change_cb);$self->reg_cb (ctcp=>\&ctcp_auto_reply_cb);$self->reg_cb (registered=>\&registered_cb);$self->reg_cb (nick_change=>\&update_ident_nick_change_cb);$self->{def_nick_change}=$self->{nick_change}=sub {my ($old_nick)=@_;"${old_nick}_"};$self->_setup_internal_dcc_handlers;$self->cleanup;return$self}sub cleanup {my ($self)=@_;$self->{channel_list}={};$self->{isupport}={};$self->{casemap_func}=$LOWER_CASEMAP{rfc1459};$self->{prefix_chars}='@+';$self->{prefix2mode}={'@'=>'o','+'=>'v' };$self->{channel_chars}='#&';$self->{change_nick_cb_guard}=$self->reg_cb (irc_437=>\&change_nick_login_cb,irc_433=>\&change_nick_login_cb,);delete$self->{away_status};delete$self->{dcc};delete$self->{dcc_id};delete$self->{_tmp_namereply};delete$self->{last_pong_recv};delete$self->{last_ping_sent};delete$self->{_ping_timer};delete$self->{con_queue};delete$self->{chan_queue};delete$self->{registered};delete$self->{idents};delete$self->{nick};delete$self->{user};delete$self->{real};delete$self->{server_pass};delete$self->{register_cb_guard}}sub connect {my ($self,$host,$port,$info)=@_;my$timeout=delete$info->{timeout};if (defined$info and keys %$info){$self->{register_cb_guard}=$self->reg_cb (ext_before_connect=>sub {my ($self,$err)=@_;unless ($err){$self->register ($info->{nick},$info->{user},$info->{real},$info->{password})}delete$self->{register_cb_guard}})}$self->SUPER::connect ($host,$port,$timeout)}sub register {my ($self,$nick,$user,$real,$pass)=@_;$self->{nick}=$nick;$self->{user}=$user;$self->{real}=$real;$self->{server_pass}=$pass;$self->send_msg ("PASS",$pass)if defined$pass;$self->send_msg ("NICK",$nick);$self->send_msg ("USER",$user || $nick,"*","0",$real || $nick)}sub set_nick_change_cb {my ($self,$cb)=@_;$cb=$self->{def_nick_change}unless defined$cb;$self->{nick_change}=$cb}sub nick {$_[0]->{nick}}sub is_my_nick {my ($self,$string)=@_;$self->eq_str ($string,$self->nick)}sub registered {$_[0]->{registered}}sub channel_list {my ($self,$chan)=@_;if (defined$chan){return$self->{channel_list}->{$self->lower_case ($chan)}}else {return$self->{channel_list}|| {}}}sub nick_modes {my ($self,$channel,$nick)=@_;my$c=$self->channel_list ($channel)or return undef;my (%lcc)=map {$self->lower_case ($_)=>$c->{$_}}keys %$c;return$lcc{$self->lower_case ($nick)}}sub send_msg {my ($self,@a)=@_;$self->event (debug_send=>@a);$self->SUPER::send_msg (@a)}sub send_srv {my ($self,@msg)=@_;if ($self->registered){$self->send_msg (@msg)}else {push @{$self->{con_queue}},\@msg}}sub clear_srv_queue {my ($self)=@_;$self->{con_queue}=[]}sub send_chan {my ($self,$chan,@msg)=@_;if ($self->{channel_list}->{$self->lower_case ($chan)}){$self->send_msg (@msg)}else {push @{$self->{chan_queue}->{$self->lower_case ($chan)}},\@msg}}sub clear_chan_queue {my ($self,$chan)=@_;$self->{chan_queue}->{$self->lower_case ($chan)}=[]}sub send_long_message {my ($self,$encoding,$overhead,$cmd,@params)=@_;my$msg=pop@params;my$ctcp;($cmd,$ctcp)=split /\001/,$cmd;my$id=$self->nick_ident ($self->nick);if ($id eq ''){$id="X" x 60}my$init_len=length mk_msg ($id,$cmd,@params," ");if ($ctcp ne ''){$init_len += length ($ctcp)+ 3}my$max_len=500;my$line_len=$max_len - $init_len;my@lines=split /\n/,$msg;@lines=map split_unicode_string ($encoding,$_,$line_len),@lines;for my$line (@lines){my$smsg=encode ($encoding,$line);if ($ctcp ne ''){$smsg=encode_ctcp ([$ctcp,$smsg])}$self->send_srv ($cmd=>@params,$smsg)}@lines}sub enable_ping {my ($self,$int,$cb)=@_;$self->{last_pong_recv}=0;$self->{last_ping_sent}=time;$self->send_srv (PING=>"AnyEvent::IRC");$self->{_ping_timer}=AE::timer$int,0,sub {if ($self->{last_pong_recv}< $self->{last_ping_sent}){delete$self->{_ping_timer};if ($cb){$cb->($self)}else {$self->disconnect ("Server timeout")}}else {$self->enable_ping ($int,$cb)}}}sub lower_case {my($self,$str)=@_;local $_=$str;$self->{casemap_func}->();return $_}sub eq_str {my ($self,$a,$b)=@_;$self->lower_case ($a)eq $self->lower_case ($b)}sub isupport {my($self,$key)=@_;if (defined ($key)){return$self->{isupport}->{$key}}else {return$self->{isupport}}}sub split_nick_mode {my ($self,$prefixed_nick)=@_;my$pchrs=$self->{prefix_chars};my%mode_map;my$nick;if ($prefixed_nick =~ /^([\Q$pchrs\E]+)(.+)$/){my$p=$1;$nick=$2;for (split //,$p){$mode_map{$self->map_prefix_to_mode ($_)}=1}}else {$nick=$prefixed_nick}my (@n)=split_prefix ($nick);if (@n > 1 && defined$n[1]){return (\%mode_map,$n[0],$nick)}else {return (\%mode_map,$nick,undef)}}sub map_prefix_to_mode {my ($self,$prefix)=@_;$self->{prefix2mode}->{$prefix}}sub map_mode_to_prefix {my ($self,$mode)=@_;for (keys %{$self->{prefix2mode}}){return $_ if$self->{prefix2mode}->{$_}eq $mode}return undef}sub available_nick_modes {my ($self)=@_;map {$self->map_prefix_to_mode ($_)}split //,$self->{prefix_chars}}sub is_channel_name {my ($self,$string)=@_;my$cchrs=$self->{channel_chars};$string =~ /^([\Q$cchrs\E]+)(.+)$/}sub nick_ident {my ($self,$nick)=@_;$self->{idents}->{$self->lower_case ($nick)}}sub away_status {$_[0]->{away_status}}sub ctcp_auto_reply {my ($self,$ctcp_command,@msg)=@_;$self->{ctcp_auto_replies}->{$ctcp_command}=\@msg}sub _setup_internal_dcc_handlers {my ($self)=@_;$self->reg_cb (ctcp_dcc=>sub {my ($self,$src,$target,$msg,$type)=@_;if ($self->is_my_nick ($target)){my ($dcc_type,$arg,$addr,$port)=split /\x20/,$msg;$dcc_type=lc$dcc_type;if ($dcc_type eq 'send'){if ($msg =~ /SEND (.*?) (\d+) (\d+)/){($arg,$addr,$port)=($1,$2,$3);$arg =~ s/^\"(.*)\"$/\1/}}$addr=format_address (pack "N",$addr);my$id=++$self->{dcc_id};$self->{dcc}->{$id}={type=>lc ($dcc_type),dest=>$self->lower_case ($src),ip=>$addr,port=>$port,arg=>$arg,};$self->event (dcc_request=>$id,$src,$dcc_type,$arg,$addr,$port)}});$self->reg_cb (dcc_ready=>sub {my ($self,$id,$dest,$type,$local_ip,$local_port)=@_;$local_ip=unpack ("N",parse_address ($local_ip));if ($type eq 'chat'){$self->send_msg (PRIVMSG=>$dest,encode_ctcp ([DCC=>"CHAT","CHAT",$local_ip,$local_port]))}elsif ($type eq 'send'){$self->send_msg (PRIVMSG=>$dest,encode_ctcp ([DCC=>"SEND","NOTHING",$local_ip,$local_port]))}});$self->reg_cb (dcc_accepted=>sub {my ($self,$id,$type,$hdl)=@_;if ($type eq 'chat'){$hdl->on_read (sub {my ($hdl)=@_;$hdl->push_read (line=>sub {my ($hdl,$line)=@_;$self->event (dcc_chat_msg=>$id,$line)})})}});$self->reg_cb (dcc_connected=>sub {my ($self,$id,$type,$hdl)=@_;if ($type eq 'chat'){$hdl->on_read (sub {my ($hdl)=@_;$hdl->push_read (line=>sub {my ($hdl,$line)=@_;$self->event (dcc_chat_msg=>$id,$line)})})}})}sub dcc_initiate {my ($self,$dest,$type,$timeout,$local_ip,$local_port)=@_;$dest=$self->lower_case ($dest);$type=lc$type;my$id=++$self->{dcc_id};my$dcc=$self->{dcc}->{$id}={id=>$id,type=>$type,dest=>$dest };weaken$dcc;weaken$self;$dcc->{timeout}=AnyEvent->timer (after=>$timeout || 5 * 60,cb=>sub {$self->dcc_disconnect ($id,"TIMEOUT")if$self});$dcc->{listener}=tcp_server undef,$local_port,sub {my ($fh,$h,$p)=@_;return unless$dcc && $self;$dcc->{handle}=AnyEvent::Handle->new (fh=>$fh,on_eof=>sub {$self->dcc_disconnect ($id,"EOF")},on_error=>sub {$self->dcc_disconnect ($id,"ERROR: $!")});$self->event (dcc_accepted=>$id,$type,$dcc->{handle});delete$dcc->{listener};delete$dcc->{timeout}},sub {my ($fh,$host,$port)=@_;return unless$dcc && $self;$local_ip=$host unless defined$local_ip;$local_port=$port;$dcc->{local_ip}=$local_ip;$dcc->{local_port}=$local_port;$self->event (dcc_ready=>$id,$dest,$type,$local_ip,$local_port)};$id}sub dcc_disconnect {my ($self,$id,$reason)=@_;if (my$dcc=delete$self->{dcc}->{$id}){delete$dcc->{handle};$self->event (dcc_close=>$id,$dcc->{type},$reason)}}sub dcc_accept {my ($self,$id,$timeout)=@_;my$dcc=$self->{dcc}->{$id}or return;weaken$dcc;weaken$self;$dcc->{timeout}=AnyEvent->timer (after=>$timeout || 5 * 60,cb=>sub {$self->dcc_disconnect ($id,"CONNECT TIMEOUT")if$self});$dcc->{connect}=tcp_connect$dcc->{ip},$dcc->{port},sub {my ($fh)=@_;return unless$dcc && $self;delete$dcc->{timeout};delete$dcc->{connect};unless ($fh){$self->dcc_disconnect ($id,"CONNECT ERROR: $!");return}$dcc->{handle}=AnyEvent::Handle->new (fh=>$fh,on_eof=>sub {delete$dcc->{handle};$self->dcc_disconnect ($id,"EOF")},on_error=>sub {delete$dcc->{handle};$self->dcc_disconnect ($id,"ERROR: $!")});$self->event (dcc_connected=>$id,$dcc->{type},$dcc->{handle})};$id}sub dcc_handle {my ($self,$id)=@_;if (my$dcc=$self->{dcc}->{$id}){return$dcc->{handle}}return}sub send_dcc_chat {my ($self,$id,$msg)=@_;if (my$dcc=$self->{dcc}->{$id}){if ($dcc->{handle}){$dcc->{handle}->push_write ("$msg\015\012")}}}sub _was_me {my ($self,$msg)=@_;$self->lower_case (prefix_nick ($msg))eq $self->lower_case ($self->nick ())}sub update_ident {my ($self,$ident)=@_;my ($n,$u,$h)=split_prefix ($ident);my$old=$self->{idents}->{$self->lower_case ($n)};$self->{idents}->{$self->lower_case ($n)}=$ident;if ($old ne $ident){$self->event (ident_change=>$n,$ident)}}sub channel_remove {my ($self,$msg,$chan,$nicks)=@_;for my$nick (@$nicks){if ($self->lower_case ($nick)eq $self->lower_case ($self->nick ())){delete$self->{chan_queue}->{$self->lower_case ($chan)};delete$self->{channel_list}->{$self->lower_case ($chan)};last}else {delete$self->{channel_list}->{$self->lower_case ($chan)}->{$nick}}}}sub channel_add {my ($self,$msg,$chan,$nicks,$modes)=@_;my@mods=@$modes;for my$nick (@$nicks){my$mode=shift@mods;if ($self->is_my_nick ($nick)){for (@{$self->{chan_queue}->{$self->lower_case ($chan)}}){$self->send_msg (@$_)}$self->clear_chan_queue ($chan)}my$ch=$self->{channel_list}->{$self->lower_case ($chan)}||= {};if (defined$mode){$ch->{$nick}=$mode;$self->event (channel_nickmode_update=>$chan,$nick)}else {$ch->{$nick}={}unless defined$ch->{$nick}}}}sub channel_mode_change {my ($self,$chan,$op,$mode,$nick)=@_;my$nickmode=$self->nick_modes ($chan,$nick);defined$nickmode or return;$op eq '+' ? $nickmode->{$mode}=1 : delete$nickmode->{$mode}}sub _filter_new_nicks_from_channel {my ($self,$chan,@nicks)=@_;grep {not exists$self->{channel_list}->{$self->lower_case ($chan)}->{$_}}@nicks}sub anymsg_cb {my ($self,$msg)=@_;my$cmd=lc$msg->{command};if ($cmd =~ /^\d\d\d$/ && not ($cmd >= 400 && $cmd <= 599)){$self->event (statmsg=>$msg)}elsif (($cmd >= 400 && $cmd <= 599)|| $cmd eq 'error'){$self->event (error=>$msg->{command},(@{$msg->{params}}? $msg->{params}->[-1]: ''),$msg)}}sub privmsg_cb {my ($self,$msg)=@_;my ($trail,$ctcp)=decode_ctcp ($msg->{params}->[-1]);for (@$ctcp){$self->event (ctcp=>prefix_nick ($msg),$msg->{params}->[0],$_->[0],$_->[1],$msg->{command});$self->event ("ctcp_".lc ($_->[0]),prefix_nick ($msg),$msg->{params}->[0],$_->[1],$msg->{command})}$msg->{params}->[-1]=$trail;if ($msg->{params}->[-1]ne ''){my$targ=$msg->{params}->[0];if ($self->is_channel_name ($targ)){$self->event (publicmsg=>$targ,$msg)}else {$self->event (privatemsg=>$targ,$msg)}}}sub welcome_cb {my ($self,$msg)=@_;if ($self->{registered}){return}$self->{registered}=1;$self->event ('registered')}sub registered_cb {my ($self,$msg)=@_;$self->send_srv (WHOIS=>$self->nick)if$self->{send_initial_whois};for (@{$self->{con_queue}}){$self->send_msg (@$_)}$self->clear_srv_queue ()}sub isupport_cb {my ($self,$msg)=@_;for (@{$msg->{params}}){if (/([A-Z]+)(?:=(.+))?/){$self->{isupport}->{$1}=defined $2 ? $2 : 1}}if (defined (my$casemap=$self->{isupport}->{CASEMAPPING})){if (defined (my$func=$LOWER_CASEMAP{$casemap})){$self->{casemap_func}=$func}else {$self->{casemap_func}=$LOWER_CASEMAP{rfc1459}}}if (defined (my$nick_prefixes=$self->{isupport}->{PREFIX})){if ($nick_prefixes =~ /^\(([^)]+)\)(.+)$/){my ($modes,$prefixes)=($1,$2);$self->{prefix_chars}=$prefixes;my@prefixes=split //,$prefixes;$self->{prefix2mode}={};for (split //,$modes){$self->{prefix2mode}->{shift@prefixes}=$_}}}if ($self->{isupport}->{NAMESX}&&!$self->{protoctl}->{NAMESX}){$self->send_srv (PROTOCTL=>'NAMESX');$self->{protoctl}->{NAMESX}=1}if ($self->{isupport}->{UHNAMES}&&!$self->{protoctl}->{UHNAMES}){$self->send_srv (PROTOCTL=>'UHNAMES');$self->{protoctl}->{UHNAMES}=1}if (defined (my$chan_prefixes=$self->{isupport}->{CHANTYPES})){$self->{channel_chars}=$chan_prefixes}}sub ping_cb {my ($self,$msg)=@_;$self->send_msg ("PONG",$msg->{params}->[0])}sub pong_cb {my ($self,$msg)=@_;$self->{last_pong_recv}=time}sub nick_cb {my ($self,$msg)=@_;my$nick=prefix_nick ($msg);my$newnick=$msg->{params}->[0];my$wasme=$self->_was_me ($msg);if ($wasme){$self->{nick}=$newnick}my@chans;for my$channame (keys %{$self->{channel_list}}){my$chan=$self->{channel_list}->{$channame};if (exists$chan->{$nick}){$chan->{$newnick}=delete$chan->{$nick};push@chans,$channame}}$self->event (nick_change=>$nick,$newnick,$wasme);for (@chans){$self->event (channel_change=>$msg,$_,$nick,$newnick,$wasme)}}sub namereply_cb {my ($self,$msg)=@_;my@nicks=split / /,$msg->{params}->[-1];push @{$self->{_tmp_namereply}},@nicks}sub endofnames_cb {my ($self,$msg)=@_;my$chan=$msg->{params}->[1];my@names_result=@{delete$self->{_tmp_namereply}};my@modes=map {($self->split_nick_mode ($_))[0]}@names_result;my@nicks=map {($self->split_nick_mode ($_))[1]}@names_result;my@idents=grep {defined}map {($self->split_nick_mode ($_))[2]}@names_result;my@new_nicks=$self->_filter_new_nicks_from_channel ($chan,@nicks);$self->channel_add ($msg,$chan,\@nicks,\@modes);$self->update_ident ($_)for@idents;$self->event (channel_add=>$msg,$chan,@new_nicks)if@new_nicks}sub whoreply_cb {my ($self,$msg)=@_;my (undef,$channel,$user,$host,$server,$nick)=@{$msg->{params}};$self->update_ident (join_prefix ($nick,$user,$host))}sub whoisuser_cb {my ($self,$msg)=@_;my (undef,$nick,$user,$host)=@{$msg->{params}};$self->update_ident (join_prefix ($nick,$user,$host))}sub join_cb {my ($self,$msg)=@_;my$chan=$msg->{params}->[0];my$nick=prefix_nick ($msg);my@new_nicks=$self->_filter_new_nicks_from_channel ($chan,$nick);$self->channel_add ($msg,$chan,[$nick],[undef]);$self->event (channel_add=>$msg,$chan,@new_nicks)if@new_nicks;$self->event (join=>$nick,$chan,$self->_was_me ($msg));if ($self->_was_me ($msg)&&!$self->isupport ('UHNAMES')){$self->send_srv (WHO=>$chan)}}sub part_cb {my ($self,$msg)=@_;my$chan=$msg->{params}->[0];my$nick=prefix_nick ($msg);$self->event (part=>$nick,$chan,$self->_was_me ($msg),$msg->{params}->[1]);$self->channel_remove ($msg,$chan,[$nick]);$self->event (channel_remove=>$msg,$chan,$nick)}sub kick_cb {my ($self,$msg)=@_;my$chan=$msg->{params}->[0];my$kicked_nick=$msg->{params}->[1];my$kicker_nick=prefix_nick($msg);$self->event (kick=>$kicked_nick,$chan,$self->_was_me ($msg),$msg->{params}->[2],$kicker_nick);$self->channel_remove ($msg,$chan,[$kicked_nick]);$self->event (channel_remove=>$msg,$chan,$kicked_nick)}sub quit_cb {my ($self,$msg)=@_;my$nick=prefix_nick ($msg);$self->event (quit=>$nick,$msg->{params}->[0]);for (keys %{$self->{channel_list}}){if ($self->{channel_list}->{$_}->{$nick}){$self->channel_remove ($msg,$_,[$nick]);$self->event (channel_remove=>$msg,$_,$nick)}}}sub mode_cb {my ($self,$msg)=@_;my$changer=prefix_nick ($msg);my ($target,$mode,$dest)=(@{$msg->{params}});if ($self->is_channel_name ($target)){if ($mode =~ /^([+-])(\S+)$/ && defined$dest){my ($op,$mode)=($1,$2);if (defined$self->map_mode_to_prefix ($mode)){$self->channel_mode_change ($target,$op,$mode,$dest);$self->event (channel_nickmode_update=>$target,$dest)}}}}sub away_change_cb {my ($self,$msg)=@_;if ($msg->{command}eq '305'){delete$self->{away_status}}else {$self->{away_status}=1}$self->event (away_status_change=>$self->{away_status})}sub debug_cb {my ($self,$msg)=@_;$self->event (debug_recv=>$msg)}sub change_nick_login_cb {my ($self,$msg)=@_;if ($self->registered){delete$self->{change_nick_cb_guard}}else {my$newnick=$self->{nick_change}->($self->nick);if ($self->lower_case ($newnick)eq $self->lower_case ($self->{nick})){$self->disconnect ("couldn't change nick to non-conflicting one");return 0}$self->{nick}=$newnick;$self->send_msg ("NICK",$newnick)}}sub disconnect_cb {my ($self)=@_;for (keys %{$self->{channel_list}}){$self->channel_remove (undef,$_,[$self->nick]);$self->event (channel_remove=>undef,$_,$self->nick)}$self->cleanup}sub rpl_topic_cb {my ($self,$msg)=@_;my$chan=$msg->{params}->[1];my$topic=$msg->{params}->[-1];$self->event (channel_topic=>$chan,$topic)}sub topic_change_cb {my ($self,$msg)=@_;my$who=prefix_nick ($msg);my$chan=$msg->{params}->[0];my$topic=$msg->{params}->[-1];$self->event (channel_topic=>$chan,$topic,$who)}sub update_ident_cb {my ($self,$msg)=@_;if (is_nick_prefix ($msg->{prefix})){$self->update_ident ($msg->{prefix})}}sub update_ident_nick_change_cb {my ($self,$old,$new)=@_;my$oldid=$self->nick_ident ($old);return unless defined$oldid;my ($n,$u,$h)=split_prefix ($oldid);$self->update_ident (join_prefix ($new,$u,$h))}sub ctcp_auto_reply_cb {my ($self,$src,$targ,$tag,$msg,$type)=@_;return if$type ne 'PRIVMSG';my$ctcprepl=$self->{ctcp_auto_replies}->{$tag}or return;if (ref ($ctcprepl->[0])eq 'CODE'){$ctcprepl=[$ctcprepl->[0]->($self,$src,$targ,$tag,$msg,$type)]}$self->send_msg (NOTICE=>$src,encode_ctcp (@$ctcprepl))}1;
ANYEVENT_IRC_CLIENT

$fatpacked{"AnyEvent/IRC/Connection.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_IRC_CONNECTION';
  package AnyEvent::IRC::Connection;use common::sense;use AnyEvent;use POSIX;use AnyEvent::Socket;use AnyEvent::Handle;use AnyEvent::IRC::Util qw/mk_msg parse_irc_msg/;use Object::Event;use Scalar::Util qw/weaken/;use base Object::Event::;sub new {my$this=shift;my$class=ref($this)|| $this;my$self=$class->SUPER::new (@_,heap=>{});bless$self,$class;$self->reg_cb (ext_after_send=>sub {my ($self,$mkmsg_args)=@_;$self->send_raw (mk_msg (@$mkmsg_args))});return$self}sub connect {my ($self,$host,$port,$prep)=@_;if ($self->{socket}){$self->disconnect ("reconnect requested.")}$self->{con_guard}=tcp_connect$host,$port,sub {my ($fh)=@_;delete$self->{socket};unless ($fh){$self->event (connect=>$!);return}$self->{host}=$host;$self->{port}=$port;$self->{socket}=AnyEvent::Handle->new (fh=>$fh,($self->{enable_ssl}? (tls=>'connect'): ()),on_eof=>sub {$self->disconnect ("EOF from server $host:$port")},on_error=>sub {$self->disconnect ("error in connection to server $host:$port: $!")},on_read=>sub {my ($hdl)=@_;$hdl->push_read (line=>qr{\015*\012},sub {$self->_feed_irc_data ($_[1])})},on_drain=>sub {$self->event ('buffer_empty')});$self->{connected}=1;$self->event ('connect')},(defined$prep ? (ref$prep ? $prep : sub {$prep}): ())}sub enable_ssl {my ($self)=@_;$self->{enable_ssl}=1}sub disconnect {my ($self,$reason)=@_;delete$self->{con_guard};delete$self->{socket};$self->event (disconnect=>$reason)}sub is_connected {my ($self)=@_;$self->{socket}&& $self->{connected}}sub heap {my ($self)=@_;return$self->{heap}}sub send_raw {my ($self,$ircline)=@_;return unless$self->{socket};$self->{socket}->push_write ($ircline ."\015\012")}sub send_msg {my ($self,@msg)=@_;$self->event (send=>[undef,@msg]);$self->event (sent=>undef,@msg)}sub _feed_irc_data {my ($self,$line)=@_;my$m=parse_irc_msg ($line);$self->event (read=>$m);$self->event ('irc_*'=>$m);$self->event ('irc_' .(lc$m->{command}),$m)}1;
ANYEVENT_IRC_CONNECTION

$fatpacked{"AnyEvent/IRC/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_IRC_UTIL';
  package AnyEvent::IRC::Util;use common::sense;use Exporter;use Encode;our@ISA=qw/Exporter/;our@EXPORT_OK=qw(mk_msg parse_irc_msg split_prefix prefix_nick decode_ctcp encode_ctcp filter_ctcp_text_attr prefix_user prefix_host rfc_code_to_name filter_colors is_nick_prefix join_prefix split_unicode_string);sub parse_irc_msg {my ($msg)=@_;$msg =~ s/^(?::([^ ]+)[ ])?([A-Za-z]+|\d{3})// or return undef;my%msg;($msg{prefix},$msg{command},$msg{params})=($1,$2,[]);my$cnt=0;while ($msg =~ s/^[ ]([^ :\015\012\0][^ \015\012\0]*)//){push @{$msg{params}},$1 if defined $1;last if ++$cnt > 13}if ($cnt==14){if ($msg =~ s/^[ ]:?([^\015\012\0]*)//){push @{$msg{params}},$1 if defined $1}}else {if ($msg =~ s/^[ ]:([^\015\012\0]*)//){push @{$msg{params}},$1 if defined $1}}\%msg}sub mk_msg {my ($prefix,$command,@params)=@_;my$msg="";$msg .= defined$prefix ? ":$prefix " : "";$msg .= "$command";my$trail;if (@params && ($params[-1]=~ /\x20/ || $params[-1]=~ /^:/)){$trail=pop@params}map {$msg .= " $_"}@params;$msg .= defined$trail ? " :$trail" : "";return$msg}my@_ctcp_lowlevel_escape=("\000","0","\012","n","\015","r","\020","\020");sub unescape_lowlevel {my ($data)=@_;my%map=reverse@_ctcp_lowlevel_escape;$data =~ s/\020(.)/defined $map{$1} ? $map{$1} : $1/ge;$data}sub escape_lowlevel {my ($data)=@_;my%map=@_ctcp_lowlevel_escape;$data =~ s/([\000\012\015\020])/"\020$map{$1}"/ge;$data}sub unescape_ctcp {my ($data)=@_;$data =~ s/\\(.)/$1 eq 'a' ? "\001" : ($1 eq "\\" ? "\\" : $1)/eg;$data}sub escape_ctcp {my ($data)=@_;$data =~ s/([\\\001])/$1 eq "\001" ? "\\a" : "\\\\"/eg;$data}sub decode_ctcp {my ($line)=@_;$line=unescape_lowlevel ($line);my@ctcp;while ($line =~ /\G\001([^\001]*)\001/g){my$msg=unescape_ctcp ($1);my ($tag,$data)=split / /,$msg,2;push@ctcp,[$tag,$data]}$line =~ s/\001[^\001]*\001//g;if ($line =~ s/\001([^\001]*)$//){my$msg=unescape_ctcp ($1);my ($tag,$data)=split / /,$msg,2;push@ctcp,[$tag,$data]}return ($line,\@ctcp)}sub encode_ctcp {my (@args)=@_;escape_lowlevel (join "",map {ref $_ ? "\001" .escape_ctcp (join " ",@$_)."\001" : $_}@args)}sub filter_colors($) {my ($line)=@_;$line =~ s/\x1B\[.*?[\x00-\x1F\x40-\x7E]//g;$line =~ s/\x03\d\d?(?:,\d\d?)?//g;$line =~ s/[\x03\x16\x02\x1f\x0f]//g;$line}sub filter_ctcp_text_attr_bogus {my ($line,$cb)=@_;return unless$cb;$line =~ s/\006([BVUSI])/{warn "FIL\n"; my $c = $cb->($1); defined $c ? $c : "\006$1"}/ieg;$line =~ s/\006CA((?:I[0-9A-F]|#[0-9A-F]{3}){2})/{my $c = $cb->($1); defined $c ? $c : "\006CA$1"}/ieg;$line =~ s/\006C([FB])(I[0-9A-F]|#[0-9A-F]{3})/{my $c = $cb->($1, $2); defined $c ? $c : "\006C$1$2"}/ieg;$line =~ s/\006CX([AFB])/{my $c = $cb->($1); defined $c ? $c : "\006CX$1"}/ieg;return$line}sub split_prefix {my ($prfx)=@_;if (ref ($prfx)eq 'HASH'){$prfx=$prfx->{prefix}}$prfx =~ m/^\s*([^!]*)(?:!([^@]*))?(?:@(.*?))?\s*$/;return ($1,$2,$3)}sub is_nick_prefix {my ($prfx)=@_;$prfx =~ m/^\s*([^!]+)!([^@]+)@(.+)?\s*$/}sub join_prefix {my ($n,$u,$h)=@_;"$n!$u\@$h"}sub prefix_nick {my ($prfx)=@_;return (split_prefix ($prfx))[0]}sub prefix_user {my ($prfx)=@_;return (split_prefix ($prfx))[1]}sub prefix_host {my ($prfx)=@_;return (split_prefix ($prfx))[2]}our%RFC_NUMCODE_MAP=('001'=>'RPL_WELCOME','002'=>'RPL_YOURHOST','003'=>'RPL_CREATED','004'=>'RPL_MYINFO','005'=>'RPL_BOUNCE','200'=>'RPL_TRACELINK','201'=>'RPL_TRACECONNECTING','202'=>'RPL_TRACEHANDSHAKE','203'=>'RPL_TRACEUNKNOWN','204'=>'RPL_TRACEOPERATOR','205'=>'RPL_TRACEUSER','206'=>'RPL_TRACESERVER','207'=>'RPL_TRACESERVICE','208'=>'RPL_TRACENEWTYPE','209'=>'RPL_TRACECLASS','210'=>'RPL_TRACERECONNECT','211'=>'RPL_STATSLINKINFO','212'=>'RPL_STATSCOMMANDS','219'=>'RPL_ENDOFSTATS','221'=>'RPL_UMODEIS','233'=>'RPL_SERVICE','234'=>'RPL_SERVLIST','235'=>'RPL_SERVLISTEND','242'=>'RPL_STATSUPTIME','243'=>'RPL_STATSOLINE','250'=>'RPL_STATSDLINE','251'=>'RPL_LUSERCLIENT','252'=>'RPL_LUSEROP','253'=>'RPL_LUSERUNKNOWN','254'=>'RPL_LUSERCHANNELS','255'=>'RPL_LUSERME','256'=>'RPL_ADMINME','257'=>'RPL_ADMINLOC1','258'=>'RPL_ADMINLOC2','259'=>'RPL_ADMINEMAIL','261'=>'RPL_TRACELOG','262'=>'RPL_TRACEEND','263'=>'RPL_TRYAGAIN','301'=>'RPL_AWAY','302'=>'RPL_USERHOST','303'=>'RPL_ISON','305'=>'RPL_UNAWAY','306'=>'RPL_NOWAWAY','311'=>'RPL_WHOISUSER','312'=>'RPL_WHOISSERVER','313'=>'RPL_WHOISOPERATOR','314'=>'RPL_WHOWASUSER','315'=>'RPL_ENDOFWHO','317'=>'RPL_WHOISIDLE','318'=>'RPL_ENDOFWHOIS','319'=>'RPL_WHOISCHANNELS','321'=>'RPL_LISTSTART','322'=>'RPL_LIST','323'=>'RPL_LISTEND','324'=>'RPL_CHANNELMODEIS','325'=>'RPL_UNIQOPIS','331'=>'RPL_NOTOPIC','332'=>'RPL_TOPIC','341'=>'RPL_INVITING','342'=>'RPL_SUMMONING','346'=>'RPL_INVITELIST','347'=>'RPL_ENDOFINVITELIST','348'=>'RPL_EXCEPTLIST','349'=>'RPL_ENDOFEXCEPTLIST','351'=>'RPL_VERSION','352'=>'RPL_WHOREPLY','353'=>'RPL_NAMREPLY','364'=>'RPL_LINKS','365'=>'RPL_ENDOFLINKS','366'=>'RPL_ENDOFNAMES','367'=>'RPL_BANLIST','368'=>'RPL_ENDOFBANLIST','369'=>'RPL_ENDOFWHOWAS','371'=>'RPL_INFO','372'=>'RPL_MOTD','374'=>'RPL_ENDOFINFO','375'=>'RPL_MOTDSTART','376'=>'RPL_ENDOFMOTD','381'=>'RPL_YOUREOPER','382'=>'RPL_REHASHING','383'=>'RPL_YOURESERVICE','384'=>'RPL_MYPORTIS','391'=>'RPL_TIME','392'=>'RPL_USERSSTART','393'=>'RPL_USERS','394'=>'RPL_ENDOFUSERS','395'=>'RPL_NOUSERS','401'=>'ERR_NOSUCHNICK','402'=>'ERR_NOSUCHSERVER','403'=>'ERR_NOSUCHCHANNEL','404'=>'ERR_CANNOTSENDTOCHAN','405'=>'ERR_TOOMANYCHANNELS','406'=>'ERR_WASNOSUCHNICK','407'=>'ERR_TOOMANYTARGETS','408'=>'ERR_NOSUCHSERVICE','409'=>'ERR_NOORIGIN','411'=>'ERR_NORECIPIENT','412'=>'ERR_NOTEXTTOSEND','413'=>'ERR_NOTOPLEVEL','414'=>'ERR_WILDTOPLEVEL','415'=>'ERR_BADMASK','421'=>'ERR_UNKNOWNCOMMAND','422'=>'ERR_NOMOTD','423'=>'ERR_NOADMININFO','424'=>'ERR_FILEERROR','431'=>'ERR_NONICKNAMEGIVEN','432'=>'ERR_ERRONEUSNICKNAME','433'=>'ERR_NICKNAMEINUSE','436'=>'ERR_NICKCOLLISION','437'=>'ERR_UNAVAILRESOURCE','441'=>'ERR_USERNOTINCHANNEL','442'=>'ERR_NOTONCHANNEL','443'=>'ERR_USERONCHANNEL','444'=>'ERR_NOLOGIN','445'=>'ERR_SUMMONDISABLED','446'=>'ERR_USERSDISABLED','451'=>'ERR_NOTREGISTERED','461'=>'ERR_NEEDMOREPARAMS','462'=>'ERR_ALREADYREGISTRED','463'=>'ERR_NOPERMFORHOST','464'=>'ERR_PASSWDMISMATCH','465'=>'ERR_YOUREBANNEDCREEP','466'=>'ERR_YOUWILLBEBANNED','467'=>'ERR_KEYSET','471'=>'ERR_CHANNELISFULL','472'=>'ERR_UNKNOWNMODE','473'=>'ERR_INVITEONLYCHAN','474'=>'ERR_BANNEDFROMCHAN','475'=>'ERR_BADCHANNELKEY','476'=>'ERR_BADCHANMASK','477'=>'ERR_NOCHANMODES','478'=>'ERR_BANLISTFULL','481'=>'ERR_NOPRIVILEGES','482'=>'ERR_CHANOPRIVSNEEDED','483'=>'ERR_CANTKILLSERVER','484'=>'ERR_RESTRICTED','485'=>'ERR_UNIQOPPRIVSNEEDED','491'=>'ERR_NOOPERHOST','492'=>'ERR_NOSERVICEHOST','501'=>'ERR_UMODEUNKNOWNFLAG','502'=>'ERR_USERSDONTMATCH',);sub rfc_code_to_name {my ($code)=@_;return$RFC_NUMCODE_MAP{$code}|| $code}sub split_unicode_string {my ($enc,$str,$maxlen)=@_;return$str unless length (encode ($enc,$str))> $maxlen;my$cur_out='';my@lines;while (length ($str)> 0){while (length (encode ($enc,$cur_out))<= $maxlen && length ($str)> 0){$cur_out .= substr$str,0,1,''}push@lines,$cur_out;$cur_out=''}@lines}1;
ANYEVENT_IRC_UTIL

$fatpacked{"AnyEvent/Impl/Cocoa.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_IMPL_COCOA';
  package AnyEvent::Impl::Cocoa;use AnyEvent ();BEGIN {AnyEvent::common_sense}use Cocoa::EventLoop;sub io {my ($class,%arg)=@_;Cocoa::EventLoop->io (%arg)}sub timer {my ($class,%arg)=@_;Cocoa::EventLoop->timer (%arg)}1
ANYEVENT_IMPL_COCOA

$fatpacked{"AnyEvent/Impl/EV.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_IMPL_EV';
  package AnyEvent::Impl::EV;use AnyEvent ();BEGIN {AnyEvent::common_sense}use EV 4.00;*AE::time=\&EV::time;*AE::now=\&EV::now;*AE::now_update=\&EV::now_update;*AE::timer=\&EV::timer;*AE::signal=\&EV::signal;*AE::idle=\&EV::idle;sub time {EV::time}sub now {EV::now}sub now_update {EV::now_update}*AE::io=defined&EV::_ae_io ? \&EV::_ae_io : sub($$$) {EV::io $_[0],$_[1]? EV::WRITE : EV::READ,$_[2]};sub timer {my ($class,%arg)=@_;EV::timer$arg{after},$arg{interval},$arg{cb}}sub io {my ($class,%arg)=@_;EV::io $arg{fh},$arg{poll}eq "r" ? EV::READ : EV::WRITE,$arg{cb}}sub signal {my ($class,%arg)=@_;EV::signal$arg{signal},$arg{cb}}sub child {my ($class,%arg)=@_;my$cb=$arg{cb};EV::child$arg{pid},0,sub {$cb->($_[0]->rpid,$_[0]->rstatus)}}sub idle {my ($class,%arg)=@_;EV::idle$arg{cb}}sub _poll {EV::run EV::RUN_ONCE}sub AnyEvent::CondVar::Base::_wait {EV::run EV::RUN_ONCE until exists $_[0]{_ae_sent}}1
ANYEVENT_IMPL_EV

$fatpacked{"AnyEvent/Impl/Event.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_IMPL_EVENT';
  package AnyEvent::Impl::Event;use AnyEvent ();BEGIN {AnyEvent::common_sense}use Event qw(unloop);sub io {my (undef,%arg)=@_;$arg{fd}=delete$arg{fh};$arg{poll}.= "e" if AnyEvent::WIN32;my$cb=$arg{cb};$arg{cb}=sub {&$cb};bless \(Event->io (%arg)),__PACKAGE__}sub timer {my (undef,%arg)=@_;$arg{after}=0 if$arg{after}< 0;my$cb=$arg{cb};$arg{cb}=sub {&$cb};bless \Event->timer (%arg,repeat=>$arg{interval}),__PACKAGE__}sub idle {my (undef,%arg)=@_;my$cb=$arg{cb};$arg{cb}=sub {&$cb};bless \Event->idle (repeat=>1,min=>0,%arg),__PACKAGE__}sub DESTROY {${$_[0]}->cancel}sub signal {my (undef,%arg)=@_;my$cb=$arg{cb};my$w=Event->signal (signal=>AnyEvent::Base::sig2name$arg{signal},cb=>sub {&$cb},);AnyEvent::Base::_sig_add;bless \$w,"AnyEvent::Impl::Event::signal"}sub AnyEvent::Impl::Event::signal::DESTROY {AnyEvent::Base::_sig_del;${$_[0]}->cancel}sub _poll {Event::one_event}sub AnyEvent::CondVar::Base::_wait {Event::one_event until exists $_[0]{_ae_sent}}1
ANYEVENT_IMPL_EVENT

$fatpacked{"AnyEvent/Impl/EventLib.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_IMPL_EVENTLIB';
  package AnyEvent::Impl::EventLib;use AnyEvent ();BEGIN {AnyEvent::common_sense}use Event::Lib;sub ccb {my$keep_it=$_[0];$_[2]()}my$ccb=\&ccb;sub io {my (undef,%arg)=@_;my ($fh,$mode)=AnyEvent::_dupfh$arg{poll},$arg{fh},EV_READ,EV_WRITE;my$w=event_new$fh,$mode | EV_PERSIST,$ccb,$arg{cb};event_add$w;bless \\$w,__PACKAGE__}sub timer {my (undef,%arg)=@_;my$ival=$arg{interval};my$cb=$arg{cb};my$w;$w=timer_new$ccb,$ival ? sub {event_add$w,$ival;&$cb}: sub {undef$w ;&$cb};event_add$w,$arg{after}|| 1e-10;bless \\$w,__PACKAGE__}sub DESTROY {local $@;${${$_[0]}}->remove}sub signal {my (undef,%arg)=@_;my$w=signal_new AnyEvent::Base::sig2num$arg{signal},$ccb,$arg{cb};event_add$w;AnyEvent::Base::_sig_add;bless \\$w,"AnyEvent::Impl::EventLib::signal"}sub AnyEvent::Impl::EventLib::signal::DESTROY {AnyEvent::Base::_sig_del;local $@;${${$_[0]}}->remove}sub _poll {event_one_loop}sub AnyEvent::CondVar::Base::_wait {event_one_loop until exists $_[0]{_ae_sent}}1
ANYEVENT_IMPL_EVENTLIB

$fatpacked{"AnyEvent/Impl/FLTK.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_IMPL_FLTK';
  package AnyEvent::Impl::FLTK;use AnyEvent ();BEGIN {AnyEvent::common_sense}use FLTK 0.532 ();use Scalar::Util ();sub timer_interval_cb {my$id=shift;$id->[0]=FLTK::add_timeout$id->[1],\&timer_interval_cb,$id;&{$id->[2]}}sub timer {my ($class,%arg)=@_;my$cb=$arg{cb};if ($arg{interval}){my$id=[undef,$arg{interval},$cb];$id->[0]=FLTK::add_timeout$arg{after},\&timer_interval_cb,$id;return bless$id,"AnyEvent::Impl::FLTK::timer"}else {return FLTK::add_timeout$arg{after},sub {&$cb}}}sub AnyEvent::Impl::FLTK::timer::DESTROY {undef $_[0][0]}sub io {my ($class,%arg)=@_;my$cb=$arg{cb};my ($fh,$ev)=AnyEvent::_dupfh$arg{poll},$arg{fh},FLTK::READ,FLTK::WRITE | (AnyEvent::WIN32 ? FLTK::EXCEPT : 0);FLTK::add_fd$fh,$ev,sub {&$cb}}sub _poll {FLTK::wait}sub AnyEvent::CondVar::Base::_wait {FLTK::wait until exists $_[0]{_ae_sent}}1
ANYEVENT_IMPL_FLTK

$fatpacked{"AnyEvent/Impl/Glib.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_IMPL_GLIB';
  package AnyEvent::Impl::Glib;use AnyEvent ();BEGIN {AnyEvent::common_sense}use Glib 1.210 ();our$mainloop=Glib::MainContext->default;my%io_cond=(r=>["in","hup"],w=>["out","hup"],);sub io {my ($class,%arg)=@_;my$cb=$arg{cb};my$fd=fileno$arg{fh};defined$fd or $fd=$arg{fh};my$source=add_watch Glib::IO $fd,$io_cond{$arg{poll}},sub {&$cb;1};bless \\$source,$class}sub timer {my ($class,%arg)=@_;my$cb=$arg{cb};my$ival=$arg{interval}* 1000;my$source;$source=add Glib::Timeout$arg{after}< 0 ? 0 : $arg{after}* 1000,$ival ? sub {remove Glib::Source$source;$source=add Glib::Timeout$ival,sub {&$cb;1};&$cb;1}: sub {remove Glib::Source$source;undef$source;&$cb;1};bless \\$source,$class}sub idle {my ($class,%arg)=@_;my$cb=$arg{cb};my$source=add Glib::Idle sub {&$cb;1};bless \\$source,$class}sub DESTROY {remove Glib::Source $${$_[0]}if defined $${$_[0]}}our%pid_w;our%pid_cb;sub child {my ($class,%arg)=@_;$arg{pid}> 0 or Carp::croak "Glib does not support watching for all pids (pid == 0) as attempted";my$pid=$arg{pid};my$cb=$arg{cb};$pid_cb{$pid}{$cb+0}=$cb;$pid_w{$pid}||= Glib::Child->watch_add ($pid,sub {undef$pid_w{$pid};$_->($_[0],$_[1])for values %{$pid_cb{$pid}};1});bless [$pid,$cb+0],"AnyEvent::Impl::Glib::child"}sub AnyEvent::Impl::Glib::child::DESTROY {my ($pid,$icb)=@{$_[0]};delete$pid_cb{$pid}{$icb};unless (%{$pid_cb{$pid}}){delete$pid_cb{$pid};my$source=delete$pid_w{$pid};remove Glib::Source if defined$source}}sub _poll {$mainloop->iteration (1)}sub AnyEvent::CondVar::Base::_wait {$mainloop->iteration (1)until exists $_[0]{_ae_sent}}1
ANYEVENT_IMPL_GLIB

$fatpacked{"AnyEvent/Impl/IOAsync.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_IMPL_IOASYNC';
  package AnyEvent::Impl::IOAsync;use AnyEvent ();BEGIN {AnyEvent::common_sense}use Time::HiRes ();use Scalar::Util ();use IO::Async::Loop 0.33;our$LOOP=new IO::Async::Loop;sub set_loop($) {$LOOP=$_[0]}sub timer {my ($class,%arg)=@_;my$cb=$arg{cb};my$id;if (my$ival=$arg{interval}){my$ival_cb;$ival_cb=sub {$id=$LOOP->enqueue_timer (delay=>$ival,code=>$ival_cb);&$cb};$id=$LOOP->enqueue_timer (delay=>$arg{after},code=>$ival_cb);Scalar::Util::weaken$ival_cb}else {$id=$LOOP->enqueue_timer (delay=>$arg{after},code=>sub {undef$id;&$cb})}bless \\$id,"AnyEvent::Impl::IOAsync::timer"}sub AnyEvent::Impl::IOAsync::timer::DESTROY {$LOOP->cancel_timer (${${$_[0]}})if defined ${${$_[0]}}}sub io {my ($class,%arg)=@_;my ($fh)=AnyEvent::_dupfh$arg{poll},$arg{fh};my$event=$arg{poll}eq "r" ? "on_read_ready" : "on_write_ready";$LOOP->watch_io (handle=>$fh,$event=>$arg{cb},);bless [$fh,$event],"AnyEvent::Impl::IOAsync::io"}sub AnyEvent::Impl::IOAsync::io::DESTROY {$LOOP->unwatch_io (handle=>$_[0][0],$_[0][1]=>1,)}sub signal {my ($class,%arg)=@_;my$signal=$arg{signal};my$id=$LOOP->attach_signal ($arg{signal},$arg{cb});bless [$signal,$id],"AnyEvent::Impl::IOAsync::signal"}sub AnyEvent::Impl::IOAsync::signal::DESTROY {$LOOP->detach_signal (@{$_[0]})}our%pid_cb;sub child {my ($class,%arg)=@_;my$pid=$arg{pid};$LOOP->watch_child ($pid,$arg{cb});bless [$pid],"AnyEvent::Impl::IOAsync::child"}sub child {my ($class,%arg)=@_;my$pid=$arg{pid};my$cb=$arg{cb};unless (%{$pid_cb{$pid}}){$LOOP->watch_child ($pid,sub {$_->($_[0],$_[1])for values %{$pid_cb{$pid}}})}$pid_cb{$pid}{$cb+0}=$cb;bless [$pid,$cb+0],"AnyEvent::Impl::IOAsync::child"}sub AnyEvent::Impl::IOAsync::child::DESTROY {my ($pid,$icb)=@{$_[0]};delete$pid_cb{$pid}{$icb};unless (%{$pid_cb{$pid}}){delete$pid_cb{$pid};$LOOP->unwatch_child ($pid)}}sub _poll {$LOOP->loop_once}sub AnyEvent::CondVar::Base::_wait {$LOOP->loop_once until exists $_[0]{_ae_sent}}1
ANYEVENT_IMPL_IOASYNC

$fatpacked{"AnyEvent/Impl/Irssi.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_IMPL_IRSSI';
  package AnyEvent::Impl::Irssi;use AnyEvent ();BEGIN {AnyEvent::common_sense}use Carp ();use Irssi ();our@ISA;sub init {my$pkg=caller;push@ISA,$pkg;local $/;eval "package $pkg; " .<DATA>;print "AnyEvent::Impl::Irssi fatal compilation error: $@" if $@;close DATA}Irssi::command "/script exec -permanent AnyEvent::Impl::Irssi::init 'AnyEvent adaptor'";1;__DATA__ 
  BEGIN { AnyEvent::common_sense }
  use base "AnyEvent::Base";
  
  sub io {
     my ($class, %arg) = @_;
     
     my $cb = $arg{cb};
     my $fd = fileno $arg{fh};
     defined $fd or $fd = $arg{fh};
  
     my $source = Irssi::input_add
        $fd,
        $arg{poll} eq "r" ? Irssi::INPUT_READ : Irssi::INPUT_WRITE,
        $cb,
        undef;
  
     bless \\$source, "AnyEvent::Impl::Irssi::io"
  }
  
  sub AnyEvent::Impl::Irssi::io::DESTROY {
     Irssi::input_remove $${$_[0]};
  }
  
  sub timer {
     my ($class, %arg) = @_;
     
     my $cb    = $arg{cb};
     my $ival  = $arg{interval} * 1000;
     my $after = $arg{after} * 1000;
  
     my $source; $source = Irssi::timeout_add_once $after > 10 ? $after : 10,
        ($ival ? sub {
                   $source = Irssi::timeout_add $ival > 10 ? $ival : 10, $cb, undef;
                   &$cb;
                   0
                 }
               : $cb),
        undef;
  
     bless \\$source, "AnyEvent::Impl::Irssi::timer"
  }
  
  sub AnyEvent::Impl::Irssi::timer::DESTROY {
     Irssi::timeout_remove $${$_[0]};
  }
  
  my $_pidwait = sub {
     my ($rpid, $rstatus) = @_;
  
     AnyEvent::Base->_emit_childstatus ($rpid, $rstatus);
  };
  
  Irssi::signal_add pidwait => $_pidwait;
  
  sub _emit_childstatus {
     my ($self, $rpid, $rstatus) = @_;
     $self->SUPER::_emit_childstatus ($rpid, $rstatus);
  
     Irssi::signal_remove pidwait => $_pidwait;
     Irssi::signal_emit   pidwait => $rpid+0, $rstatus+0;
     Irssi::signal_add    pidwait => $_pidwait;
  }
  
  #sub loop {
  #   Carp::croak "Irssi does not support blocking waits";
  #}
  
  =head1 SEE ALSO
  
  L<AnyEvent>, L<Irssi>.
  
  =head1 AUTHOR
  
   Marc Lehmann <schmorp@schmorp.de>
   http://anyevent.schmorp.de
  
  =cut
  
  1
  
ANYEVENT_IMPL_IRSSI

$fatpacked{"AnyEvent/Impl/POE.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_IMPL_POE';
  package AnyEvent::Impl::POE;use AnyEvent ();BEGIN {AnyEvent::common_sense}use POE;${POE::Kernel->new->[POE::Kernel::KR_RUN]}|= POE::Kernel::KR_RUN_CALLED;sub io {my ($class,%arg)=@_;my ($fh,$pee)=AnyEvent::_dupfh$arg{poll},$arg{fh},"select_read","select_write";my$cb=delete$arg{cb};my$cb=sub {&$cb};my$session=POE::Session->create (inline_states=>{_start=>sub {$_[KERNEL]->$pee ($fh=>"ready")},ready=>sub {$cb->()},stop=>sub {$_[KERNEL]->$pee ($fh)},},);bless \\$session,"AnyEvent::Impl::POE"}sub timer {my ($class,%arg)=@_;my$after=delete$arg{after};my$ival=delete$arg{interval};my$cb=delete$arg{cb};my$cb=sub {&$cb};my$session=POE::Session->create (inline_states=>{_start=>sub {$_[KERNEL]->delay_set (timeout=>$after)},timeout=>$ival ? sub {$_[KERNEL]->delay_set (timeout=>$ival);$cb->()}: $cb,stop=>sub {$_[KERNEL]->alarm_remove_all},},);bless \\$session,"AnyEvent::Impl::POE"}sub signal {my ($class,%arg)=@_;my$signal=AnyEvent::Base::sig2name delete$arg{signal};my$cb=delete$arg{cb};my$cb=sub {&$cb};my$session=POE::Session->create (inline_states=>{_start=>sub {},start=>sub {$_[KERNEL]->sig ($signal=>"catch");$_[KERNEL]->refcount_increment ($_[SESSION]->ID=>"poe")},catch=>sub {$cb->();$_[KERNEL]->sig_handled},stop=>sub {$_[KERNEL]->refcount_decrement ($_[SESSION]->ID=>"poe");$_[KERNEL]->sig ($signal)},},);POE::Kernel->call ($session,"start");bless \\$session,"AnyEvent::Impl::POE"}sub child {my ($class,%arg)=@_;my$pid=delete$arg{pid};my$cb=delete$arg{cb};my$cb=sub {&$cb};my$session=POE::Session->create (inline_states=>{_start=>sub {},start=>sub {$_[KERNEL]->sig (CHLD=>"child");$_[KERNEL]->refcount_increment ($_[SESSION]->ID=>"poe")},child=>sub {my ($rpid,$status)=@_[ARG1,ARG2];$cb->($rpid,$status)if$rpid==$pid || $pid==0},stop=>sub {$_[KERNEL]->refcount_decrement ($_[SESSION]->ID=>"poe");$_[KERNEL]->sig ("CHLD")},},);POE::Kernel->call ($session,"start");bless \\$session,"AnyEvent::Impl::POE"}sub DESTROY {POE::Kernel->call (${${$_[0]}},"stop")}sub _poll {POE::Kernel->loop_do_timeslice}sub AnyEvent::CondVar::Base::_wait {POE::Kernel->loop_do_timeslice until exists $_[0]{_ae_sent}}1
ANYEVENT_IMPL_POE

$fatpacked{"AnyEvent/Impl/Perl.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_IMPL_PERL';
  package AnyEvent::Impl::Perl;use AnyEvent ();BEGIN {AnyEvent::common_sense}use AnyEvent::Loop;our$VERSION=$AnyEvent::VERSION;*AE::now=\&AnyEvent::Loop::now;*AE::now_update=\&AnyEvent::Loop::now_update;*AE::io=\&AnyEvent::Loop::io;*AE::timer=\&AnyEvent::Loop::timer;*AE::idle=\&AnyEvent::Loop::idle;*_poll=\&AnyEvent::Loop::one_event;*loop=\&AnyEvent::Loop::run;*now_update=\&AnyEvent::Loop::now_update;sub now {$AnyEvent::Loop::NOW}sub AnyEvent::CondVar::Base::_wait {AnyEvent::Loop::one_event until exists $_[0]{_ae_sent}}sub io {my (undef,%arg)=@_;AnyEvent::Loop::io$arg{fh},$arg{poll}eq "w",$arg{cb}}sub timer {my (undef,%arg)=@_;AnyEvent::Loop::timer$arg{after},$arg{interval},$arg{cb}}sub idle {my (undef,%arg)=@_;AnyEvent::Loop::idle$arg{cb}}1
ANYEVENT_IMPL_PERL

$fatpacked{"AnyEvent/Impl/Qt.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_IMPL_QT';
  package AnyEvent::Impl::Qt::Io;use Qt;use Qt::isa qw(Qt::SocketNotifier);use Qt::slots cb=>[];sub NEW {my ($class,$fh,$mode,$cb)=@_;shift->SUPER::NEW (fileno$fh,$mode);this->{fh}=$fh;this->{cb}=$cb;this->connect (this,SIGNAL "activated(int)",SLOT "cb()")}sub cb {this->setEnabled (0);this->{cb}->();this->setEnabled (1)}package AnyEvent::Impl::Qt::Timer;use Qt;use Qt::isa qw(Qt::Timer);use Qt::slots cb=>[];sub NEW {my ($class,$after,$interval,$cb)=@_;shift->SUPER::NEW ();this->{interval}=$interval;this->{cb}=$cb;this->connect (this,SIGNAL "timeout()",SLOT "cb()");this->start ($after,1)}sub cb {this->start (this->{interval},1)if defined this->{interval};this->{cb}->()}package AnyEvent::Impl::Qt;use AnyEvent ();BEGIN {AnyEvent::common_sense}use Qt;use AnyEvent::Impl::Qt::Timer;use AnyEvent::Impl::Qt::Io;our$app=Qt::Application \@ARGV;sub io {my ($class,%arg)=@_;my ($fh,$qt)=AnyEvent::_dupfh$arg{poll},$arg{fh},Qt::SocketNotifier::Read (),Qt::SocketNotifier::Write ();AnyEvent::Impl::Qt::Io$fh,$qt,$arg{cb}}sub timer {my ($class,%arg)=@_;AnyEvent::Impl::Qt::Timer $arg{after}* 1000 || 1,$arg{interval}? $arg{interval}* 1000 || 1 : undef,$arg{cb}}sub _poll {Qt::app->processOneEvent}sub AnyEvent::CondVar::Base::_wait {Qt::app->processOneEvent until exists $_[0]{_ae_sent}}1
ANYEVENT_IMPL_QT

$fatpacked{"AnyEvent/Impl/Tk.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_IMPL_TK';
  package AnyEvent::Impl::Tk;use AnyEvent ();BEGIN {AnyEvent::common_sense}use Tk ();our$mw=new MainWindow -title=>"AnyEvent Dummy Window";$mw->withdraw;END {undef$mw}sub io {my (undef,%arg)=@_;my ($fh,$tk)=AnyEvent::_dupfh$arg{poll},$arg{fh},"readable","writable";$mw->fileevent ($fh,$tk=>$arg{cb});bless [$fh,$tk],"AnyEvent::Impl::Tk::io"}sub AnyEvent::Impl::Tk::io::DESTROY {my ($fh,$tk)=@{$_[0]};$mw->fileevent ($fh,$tk=>"")}sub timer {my (undef,%arg)=@_;my$after=$arg{after}< 0 ? 0 : $arg{after}* 1000;my$cb=$arg{cb};my$id;if ($arg{interval}){my$ival=$arg{interval}* 1000;my$rcb=sub {$id=Tk::after$mw,$ival,[$_[0],$_[0]];&$cb};$id=Tk::after$mw,$after,[$rcb,$rcb]}else {$id=Tk::after$mw,$after,sub {&$cb}}bless \\$id,"AnyEvent::Impl::Tk::after"}sub idle {my (undef,%arg)=@_;my$cb=$arg{cb};my$id;my$rcb=sub {$id=Tk::after$mw,0=>[sub {$id=Tk::after$mw,idle=>[$_[0],$_[0]]},$_[0]];&$cb};$id=Tk::after$mw,idle=>[$rcb,$rcb];bless \\$id,"AnyEvent::Impl::Tk::after"}sub AnyEvent::Impl::Tk::after::DESTROY {Tk::after$mw,cancel=>$${$_[0]}}sub _poll {Tk::DoOneEvent (0)}sub AnyEvent::CondVar::Base::_wait {Tk::DoOneEvent (0)until exists $_[0]{_ae_sent}}1
ANYEVENT_IMPL_TK

$fatpacked{"AnyEvent/Impl/UV.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_IMPL_UV';
  package AnyEvent::Impl::UV;use AnyEvent ();BEGIN {AnyEvent::common_sense}use UV 0.24;use Scalar::Util qw(weaken);sub warnlog {my$err=UV::last_error;AnyEvent::log warn=>"returned $_[0]: " .UV::err_name ($err)."($err): " .UV::strerror ($err);@_}my%io_watchers;sub io_watcher_cb {my$slaves=shift;my (undef,$events)=@_;return unless defined$slaves;for my$entry (keys %$slaves){my$slave=$slaves->{$entry};$slave->{cb}(@_)if$slave->{mode}& $events}}sub AnyEvent::Impl::UV::io_slave::new {bless {parent=>$_[1]},$_[0]}sub AnyEvent::Impl::UV::io_slave::DESTROY {my$self=$_[0];my$master=$self->{parent};delete$master->{slaves}{$self};if (keys %{$master->{slaves}}==0){if (defined$master->{w}){my$rc=UV::poll_stop$master->{w};warnlog$rc if$rc}delete$io_watchers{$master->{fd}};return}my$mode=0;for my$entry (keys %{$master->{slaves}}){$mode |= $master->{slaves}{$entry}{mode}}if ($master->{mode}!=$mode){$master->{mode}=$mode;my$rc=UV::poll_start$master->{w},$master->{mode},sub {io_watcher_cb$master->{slaves},@_};warnlog$rc if$rc}}sub io {my ($class,%arg)=@_;my$fd=fileno$arg{fh};defined$fd or $fd=$arg{fh};my$master=$io_watchers{$fd}||= {fd=>$fd };unless (defined$master->{w}){$master->{w}=UV::poll_init$fd;return warnlog$master->{w}unless defined$master->{w};$master->{slaves}={}}my$slave=AnyEvent::Impl::UV::io_slave->new ($master);weaken ($master->{slaves}->{$slave}=$slave);$slave->{mode}=$arg{poll}eq "r" ? UV::READABLE : UV::WRITABLE;$master->{mode}=0 unless defined$master->{mode};$slave->{cb}=$arg{cb};unless ($master->{mode}& $slave->{mode}){$master->{mode}|= $slave->{mode};my$rc=UV::poll_start$master->{w},$master->{mode},sub {io_watcher_cb$master->{slaves},@_};warnlog$rc if$rc}$slave}sub AnyEvent::Impl::UV::handle::new {my ($class,$w,$start,$stop,@args)=@_;return warnlog$w unless defined$w;my$rc=$start->($w,@args);warnlog$rc if$rc;bless {w=>$w,stop=>$stop },$class}sub AnyEvent::Impl::UV::handle::DESTROY {my$h=$_[0];return unless$h->{w};my$rc=$h->{stop}($h->{w});warnlog$rc if$rc;UV::close$h->{w}}sub idle {my ($class,%arg)=@_;AnyEvent::Impl::UV::handle->new (UV::timer_init,\&UV::idle_start,\&UV::idle_stop,$arg{cb})}sub timer {my ($class,%arg)=@_;AnyEvent::Impl::UV::handle->new (UV::timer_init,\&UV::timer_start,\&UV::timer_stop,$arg{after}* 1000,$arg{interval}* 1000,$arg{cb})}sub now {UV::now}sub _poll {UV::run UV::RUN_ONCE}sub AnyEvent::CondVar::Base::_wait {UV::run UV::RUN_NOWAIT until exists $_[0]{_ae_sent}}1
ANYEVENT_IMPL_UV

$fatpacked{"AnyEvent/Log.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_LOG';
  package AnyEvent::Log;use Carp ();use POSIX ();use AnyEvent ();BEGIN {AnyEvent::common_sense}our$VERSION=$AnyEvent::VERSION;our ($COLLECT,$FILTER,$LOG);our ($now_int,$now_str1,$now_str2);sub format_time($) {my$i=int $_[0];my$f=sprintf "%06d",1e6 * ($_[0]- $i);($now_int,$now_str1,$now_str2)=($i,split /\x01/,POSIX::strftime "%Y-%m-%d %H:%M:%S.\x01 %z",localtime$i)if$now_int!=$i;"$now_str1$f$now_str2"}our%CTX;sub _pkg_ctx($) {my$ctx=bless [$_[0],(1 << 10)- 1 - 1,{}],"AnyEvent::Log::Ctx";my$parent=$_[0]=~ /^(.+)::/ ? $CTX{$1}||= &_pkg_ctx ("$1"): $COLLECT;$ctx->[2]{$parent+0}=$parent;$ctx}our%STR2LEVEL=(fatal=>1,emerg=>1,exit=>1,alert=>2,critical=>3,crit=>3,error=>4,err=>4,die=>4,warn=>5,warning=>5,note=>6,notice=>6,info=>7,debug=>8,trace=>9,);our$TIME_EXACT;sub exact_time($) {$TIME_EXACT=shift;*_ts=$AnyEvent::MODEL ? $TIME_EXACT ? \&AE::now : \&AE::time : sub () {$TIME_EXACT ? do {require Time::HiRes;Time::HiRes::time ()}: time}}BEGIN {exact_time 0}AnyEvent::post_detect {exact_time$TIME_EXACT};our@LEVEL2STR=qw(0 fatal alert crit error warn note info debug trace);sub default_format($$$$) {my$ts=format_time $_[0];my$ct=" ";my@res;for (split /\n/,sprintf "%-5s %s: %s",$LEVEL2STR[$_[2]],$_[1][0],$_[3]){push@res,"$ts$ct$_\n";$ct=" + "}join "",@res}sub fatal_exit() {exit 1}sub _log {my ($ctx,$level,$format,@args)=@_;$level=$level > 0 && $level <= 9 ? $level+0 : $STR2LEVEL{$level}|| Carp::croak "$level: not a valid logging level, caught";my$mask=1 << $level;my ($success,%seen,@ctx,$now,@fmt);do {if (!ref$ctx){$level=$ctx}elsif ($ctx->[1]& $mask and!$seen{$ctx+0}++){if ($ctx->[5]> $level){push@ctx,$level;$level=$ctx->[5]}if ($ctx->[3]){local ($!,$@);unless ($now){$format=$format->()if ref$format;$format=sprintf$format,@args if@args;$format =~ s/\n$//;$now=_ts};my$str=$ctx->[4]? $ctx->[4]($now,$_[0],$level,$format): ($fmt[$level]||= default_format$now,$_[0],$level,$format);$success=1;$ctx->[3]($str)or push@ctx,values %{$ctx->[2]}}else {push@ctx,values %{$ctx->[2]}}}}while$ctx=pop@ctx;fatal_exit if$level <= 1;$success}sub log($$;@) {_log $CTX{(caller)[0]}||= _pkg_ctx +(caller)[0],@_}our%LOGGER;sub _reassess {local$SIG{__DIE__};my$die=sub {die};for (@_ ? $LOGGER{$_[0]}: values%LOGGER){my ($ctx,$level,$renabled)=@$_;$$renabled=!eval {_log$ctx,$level,$die;1}}}sub _logger {my ($ctx,$level,$renabled)=@_;$$renabled=1;my$logger=[$ctx,$level,$renabled];$LOGGER{$logger+0}=$logger;_reassess$logger+0;require AnyEvent::Util unless$AnyEvent::Util::VERSION;my$guard=AnyEvent::Util::guard (sub {delete$LOGGER{$logger+0}});sub {$guard if 0;_log$ctx,$level,@_ if $$renabled}}sub logger($;$) {_logger $CTX{(caller)[0]}||= _pkg_ctx +(caller)[0],@_}sub ctx(;$) {my$pkg=@_ ? shift : (caller)[0];ref$pkg ? $pkg : defined$pkg ? $CTX{$pkg}||= AnyEvent::Log::_pkg_ctx$pkg : bless [undef,(1 << 10)- 1 - 1],"AnyEvent::Log::Ctx"}our$ORIG_VERBOSE=$AnyEvent::VERBOSE;$AnyEvent::VERBOSE=9;sub reset {while (my ($k,$v)=each%CTX){@$v=($k,(1 << 10)- 1 - 1,{});$v->attach ($k =~ /^(.+)::/ ? $CTX{$1}: $AnyEvent::Log::COLLECT)}@$_=($_->[0],(1 << 10)- 1 - 1)for$LOG,$FILTER,$COLLECT;$LOG->title ('$AnyEvent::Log::LOG');$LOG->log_to_warn;$FILTER->slaves ($LOG);$FILTER->title ('$AnyEvent::Log::FILTER');$FILTER->level ($ORIG_VERBOSE);$COLLECT->slaves ($FILTER);$COLLECT->title ('$AnyEvent::Log::COLLECT');_reassess}*AnyEvent::log=*AE::log=\&log;*AnyEvent::logger=*AE::logger=\&logger;$_->[0]=ctx $_->[0]for values%LOGGER;$LOG=ctx undef;$FILTER=ctx undef;$COLLECT=ctx undef;AnyEvent::Log::reset;package AnyEvent::Log::LOG;package AE::Log::LOG;package AnyEvent::Log::FILTER;package AE::Log::FILTER;package AnyEvent::Log::COLLECT;package AE::Log::COLLECT;package AnyEvent::Log::Ctx;sub new {my$class=shift;my$ctx=AnyEvent::Log::ctx undef;while (@_){my ($k,$v)=splice @_,0,2;$ctx->$k (ref$v eq "ARRAY" ? @$v : $v)}bless$ctx,$class}sub title {$_[0][0]=$_[1]if @_ > 1;$_[0][0]}sub _lvl_lst {map {$_ > 0 && $_ <= 9 ? $_+0 : $_ eq "all" ? (1 .. 9): $STR2LEVEL{$_}|| Carp::croak "$_: not a valid logging level, caught"}@_}sub _lvl {$_[0]=~ /^(?:0|off|none)$/ ? 0 : (_lvl_lst $_[0])[-1]}our$NOP_CB=sub {0};sub levels {my$ctx=shift;$ctx->[1]=0;$ctx->[1]|= 1 << $_ for&_lvl_lst;AnyEvent::Log::_reassess}sub level {my$ctx=shift;$ctx->[1]=((1 << &_lvl)- 1)<< 1;AnyEvent::Log::_reassess}sub enable {my$ctx=shift;$ctx->[1]|= 1 << $_ for&_lvl_lst;AnyEvent::Log::_reassess}sub disable {my$ctx=shift;$ctx->[1]&= ~(1 << $_)for&_lvl_lst;AnyEvent::Log::_reassess}sub cap {my$ctx=shift;$ctx->[5]=&_lvl}sub attach {my$ctx=shift;$ctx->[2]{$_+0}=$_ for map {AnyEvent::Log::ctx $_}@_}sub detach {my$ctx=shift;delete$ctx->[2]{$_+0}for map {AnyEvent::Log::ctx $_}@_}sub slaves {undef $_[0][2];&attach}sub log_cb {my ($ctx,$cb)=@_;$ctx->[3]=$cb}sub fmt_cb {my ($ctx,$cb)=@_;$ctx->[4]=$cb}sub log_to_warn {my ($ctx,$path)=@_;$ctx->log_cb (sub {warn shift;0})}sub _log_to_disk {eval q{ # poor man's autoloading {}
        sub _log_to_disk {
           my ($ctx, $path, $keepopen) = @_;
  
           my $fh;
           my @queue;
           my $delay;
           my $disable;
  
           use AnyEvent::IO ();
  
           my $kick = sub {
              undef $delay;
              return unless @queue;
              $delay = 1;
  
              # we pass $kick to $kick, so $kick itself doesn't keep a reference to $kick.
              my $kick = shift;
  
              # write one or more messages
              my $write = sub {
                 # we write as many messages as have been queued
                 my $data = join "", @queue;
                 @queue = ();
  
                 AnyEvent::IO::aio_write $fh, $data, sub {
                    $disable = 1;
                    @_
                       ? ($_[0] == length $data or AE::log 4 => "unable to write to logfile '$path': short write")
                       :                           AE::log 4 => "unable to write to logfile '$path': $!";
                    undef $disable;
  
                    if ($keepopen) {
                       $kick->($kick);
                    } else {
                       AnyEvent::IO::aio_close ($fh, sub {
                          undef $fh;
                          $kick->($kick);
                       });
                    }
                 };
              };
  
              if ($fh) {
                 $write->();
              } else {
                 AnyEvent::IO::aio_open
                    $path,
                    AnyEvent::IO::O_CREAT | AnyEvent::IO::O_WRONLY | AnyEvent::IO::O_APPEND,
                    0666,
                    sub {
                       $fh = shift
                          or do {
                             $disable = 1;
                             AE::log 4 => "unable to open logfile '$path': $!";
                             undef $disable;
                             return;
                          };
  
                       $write->();
                    }
                 ;
              }
           };
  
           $ctx->log_cb (sub {
              return if $disable;
              push @queue, shift;
              $kick->($kick) unless $delay;
              0
           });
  
           $kick->($kick) if $keepopen; # initial open
        };
     };die if $@;&_log_to_disk}sub log_to_file {my ($ctx,$path)=@_;_log_to_disk$ctx,$path,1}sub log_to_path {my ($ctx,$path)=@_;_log_to_disk$ctx,$path,0}sub log_to_syslog {my ($ctx,$facility)=@_;require Sys::Syslog;$ctx->fmt_cb (sub {my$str=$_[3];$str =~ s/\n(?=.)/\n+ /g;[$_[2],"($_[1][0]) $str"]});$facility ||= "user";$ctx->log_cb (sub {my$lvl=$_[0][0]< 9 ? $_[0][0]: 8;Sys::Syslog::syslog ("$facility|" .($lvl - 1),$_)for split /\n/,$_[0][1];0})}*log=\&AnyEvent::Log::_log;*logger=\&AnyEvent::Log::_logger;package AnyEvent::Log;for (my$spec=$ENV{PERL_ANYEVENT_LOG}){my%anon;my$pkg=sub {$_[0]eq "log" ? $LOG : $_[0]eq "filter" ? $FILTER : $_[0]eq "collect" ? $COLLECT : $_[0]=~ /^%(.+)$/ ? ($anon{$1}||= do {my$ctx=ctx undef;$ctx->[0]=$_[0];$ctx}): $_[0]=~ /^(.*?)(?:::)?$/ ? ctx "$1" : die};/\G[[:space:]]+/gc;while (/\G((?:[^:=[:space:]]+|::|\\.)+)=/gc){my$ctx=$pkg->($1);my$level="level";while (/\G((?:[^,:[:space:]]+|::|\\.)+)/gc){for ("$1"){if ($_ eq "stderr"){$ctx->log_to_warn}elsif (/^file=(.+)/){$ctx->log_to_file ("$1")}elsif (/^path=(.+)/){$ctx->log_to_path ("$1")}elsif (/^syslog(?:=(.*))?/){require Sys::Syslog;$ctx->log_to_syslog ("$1")}elsif ($_ eq "nolog"){$ctx->log_cb (undef)}elsif (/^cap=(.+)/){$ctx->cap ("$1")}elsif (/^\+(.+)$/){$ctx->attach ($pkg->("$1"))}elsif ($_ eq "+"){$ctx->slaves}elsif ($_ eq "off" or $_ eq "0"){$ctx->level (0)}elsif ($_ eq "all"){$ctx->level ("all")}elsif ($_ eq "level"){$ctx->level ("all");$level="level"}elsif ($_ eq "only"){$ctx->level ("off");$level="enable"}elsif ($_ eq "except"){$ctx->level ("all");$level="disable"}elsif (/^\d$/){$ctx->$level ($_)}elsif (exists$STR2LEVEL{$_}){$ctx->$level ($_)}else {die "PERL_ANYEVENT_LOG ($spec): parse error at '$_'\n"}}/\G,/gc or last}/\G[:[:space:]]+/gc or last}/\G[[:space:]]+/gc;if (/\G(.+)/g){die "PERL_ANYEVENT_LOG ($spec): parse error at '$1'\n"}}1
ANYEVENT_LOG

$fatpacked{"AnyEvent/Loop.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_LOOP';
  package AnyEvent::Loop;use Scalar::Util qw(weaken);use List::Util ();use AnyEvent ();BEGIN {AnyEvent::common_sense}use AnyEvent::Util ();our$VERSION=$AnyEvent::VERSION;our ($NOW,$MNOW);sub MAXWAIT() {3600}BEGIN {local$SIG{__DIE__};my$time_hires=eval "use Time::HiRes (); 1";my$clk_tck=eval "use POSIX (); POSIX::sysconf (POSIX::_SC_CLK_TCK ())";my$round;if ($time_hires && eval "&Time::HiRes::clock_gettime (Time::HiRes::CLOCK_MONOTONIC ())"){AE::log 8=>"Using CLOCK_MONOTONIC as timebase.";*_update_clock=sub {$NOW=&Time::HiRes::time;$MNOW=Time::HiRes::clock_gettime (&Time::HiRes::CLOCK_MONOTONIC)}}elsif (100 <= $clk_tck && $clk_tck <= 1000000 && eval {(POSIX::times ())[0]!=-1}){AE::log 8=>"Using POSIX::times (monotonic) as timebase.";my$HZ1=1 / $clk_tck;my$last=(POSIX::times ())[0];my$next;*_update_clock=sub {$NOW=time;$next=(POSIX::times ())[0];$last -= 4294967296 if$last > $next;$MNOW += ($next - $last)* $HZ1;$last=$next};$round=$HZ1}elsif (eval "use Time::HiRes (); 1"){AE::log 8=>"Using Time::HiRes::time (non-monotonic) clock as timebase.";*_update_clock=sub {$NOW=$MNOW=&Time::HiRes::time}}else {AE::log fatal=>"Unable to find sub-second time source (is this really perl 5.8.0 or later?)"}$round=0.001 if$round < 0.001;$round -= $round * 1e-2;eval "sub ROUNDUP() { $round }"}_update_clock;sub now () {$NOW}sub now_update() {_update_clock}my@fds=([],[]);sub V() {0}sub W() {1}my$need_sort=1e300;my@timer;my@idle;sub one_event {_update_clock;if ($MNOW >= $need_sort){$need_sort=1e300;@timer=sort {$a->[0]<=> $b->[0]}@timer}if (@timer && $timer[0][0]<= $MNOW){do {my$timer=shift@timer;$timer->[1]&& $timer->[1]($timer)}while@timer && $timer[0][0]<= $MNOW}else {my ($wait,@vec,$fds)=(@timer && $timer[0][0]< $need_sort ? $timer[0][0]: $need_sort)- $MNOW;$wait=$wait < MAXWAIT ? $wait + ROUNDUP : MAXWAIT;$wait=0 if@idle;$fds=CORE::select $vec[0]=$fds[0][V],$vec[1]=$fds[1][V],AnyEvent::WIN32 ? $vec[2]=$fds[1][V]: undef,$wait;_update_clock;if ($fds > 0){$vec[1]|= $vec[2]if AnyEvent::WIN32;for (1,0){my$fds=$fds[$_];for (unpack "b*",$vec[$_]){while (/1/g){$_ && $_->[2]()for @{$fds->[W][(pos)- 1]|| []}}}}}elsif (AnyEvent::WIN32 && $fds && $!==AnyEvent::Util::WSAEINVAL){CORE::select undef,undef,undef,$wait if$wait}elsif (!@timer || $timer[0][0]> $MNOW &&!$fds){$$$_ && $$$_->()for@idle=grep $$$_,@idle}}}sub run {one_event while 1}sub io($$$) {my ($fd,$write,$cb)=@_;defined ($fd=fileno$fd)or $fd=$_[0];my$self=bless [$fd,$write,$cb,],"AnyEvent::Loop::io";my$fds=$fds[$self->[1]];my$q=$fds->[W][$fd]||= [];(vec$fds->[V],$fd,1)=1;$self->[3]=@$q;push @$q,$self;weaken$q->[-1];$self}sub AnyEvent::Loop::io::DESTROY {my ($self)=@_;my$fds=$fds[$self->[1]];my$fd=$self->[0];if (@{$fds->[W][$fd]}==1){delete$fds->[W][$fd];(vec$fds->[V],$fd,1)=0}else {my$q=$fds->[W][$fd];my$last=pop @$q;if ($last!=$self){weaken ($q->[$self->[3]]=$last);$last->[3]=$self->[3]}}}sub timer($$$) {my ($after,$interval,$cb)=@_;my$self;if ($interval){$self=[$MNOW + $after,sub {$_[0][0]=List::Util::max $_[0][0]+ $interval,$MNOW;push@timer,$_[0];weaken$timer[-1];$need_sort=$_[0][0]if $_[0][0]< $need_sort;&$cb}]}else {$self=[$MNOW + $after,$cb]}push@timer,$self;weaken$timer[-1];$need_sort=$self->[0]if$self->[0]< $need_sort;$self}sub idle($) {my$cb=shift;push@idle,\\$cb;weaken ${$idle[-1]};${$idle[-1]}}1
ANYEVENT_LOOP

$fatpacked{"AnyEvent/Socket.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_SOCKET';
  package AnyEvent::Socket;use Carp ();use Errno ();use Socket qw(AF_INET AF_UNIX SOCK_STREAM SOCK_DGRAM SOL_SOCKET SO_REUSEADDR);use AnyEvent ();BEGIN {AnyEvent::common_sense}use AnyEvent::Util qw(guard AF_INET6);use AnyEvent::DNS ();use base 'Exporter';our@EXPORT=qw(getprotobyname parse_hostport format_hostport parse_ipv4 parse_ipv6 parse_ip parse_address format_ipv4 format_ipv6 format_ip format_address address_family inet_aton tcp_server tcp_connect);our$VERSION=$AnyEvent::VERSION;sub parse_ipv4($) {$_[0]=~ /^      (?: 0x[0-9a-fA-F]+ | 0[0-7]* | [1-9][0-9]* )
                (?:\. (?: 0x[0-9a-fA-F]+ | 0[0-7]* | [1-9][0-9]* ) ){0,3}$/x or return undef;@_=map /^0/ ? oct : $_,split /\./,$_[0];return undef if grep $_ >= 256,@_[0 .. @_ - 2];return undef if $_[-1]>= 2 ** (8 * (4 - $#_));pack "N",(pop)+ ($_[0]<< 24)+ ($_[1]<< 16)+ ($_[2]<< 8)}sub parse_ipv6($) {my$n=$_[0]=~ y/://;return undef if$n < 2 || $n > 8;my ($h,$t)=split /::/,$_[0],2;unless (defined$t){($h,$t)=(undef,$h)}my@h=split /:/,$h,-1;my@t=split /:/,$t,-1;if (@t && $t[-1]=~ /\./){return undef if$n > 6;my$ipn=parse_ipv4 pop@t or return undef;push@t,map +(sprintf "%x",$_),unpack "nn",$ipn}return undef unless@h + @t==8 || $_[0]=~ /::/;return undef if grep!/^[0-9a-fA-F]{1,4}$/,@h,@t;push@h,0 while@h + @t < 8;pack "n*",map hex,@h,@t}sub parse_unix($) {$_[0]eq "unix/" ? pack "S",AF_UNIX : undef}sub parse_address($) {for (&parse_ipv6){if ($_){s/^\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xff//;return $_}else {return&parse_ipv4 || &parse_unix}}}*aton=\&parse_address;our%PROTO_BYNAME;$PROTO_BYNAME{tcp}=Socket::IPPROTO_TCP ()if defined&Socket::IPPROTO_TCP;$PROTO_BYNAME{udp}=Socket::IPPROTO_UDP ()if defined&Socket::IPPROTO_UDP;$PROTO_BYNAME{icmp}=Socket::IPPROTO_ICMP()if defined&Socket::IPPROTO_ICMP;sub getprotobyname($) {my$name=lc shift;defined (my$proton=$PROTO_BYNAME{$name}|| (getprotobyname$name)[2])or return;($name,uc$name,$proton)}sub parse_hostport($;$) {my ($host,$port);for ("$_[0]"){return ("unix/",$_)if m%^/%;unless (($host)=/^\s* ([0-9a-fA-F:]*:[0-9a-fA-F:]*:[0-9a-fA-F\.:]*)/xgc and parse_ipv6$host){/^\s*/xgc;if (/^ \[ ([^\[\]]+) \]/xgc){$host=$1}elsif (/^ ([^\[\]:\ ]+) /xgc){$host=$1}else {return}}if (/\G (?:\s+|:|\#) ([^:[:space:]]+) \s*$/xgc){$port=$1}elsif (/\G\s*$/gc && length $_[1]){$port=$_[1]}else {return}}return if$host =~ /:/ &&!parse_ipv6$host;($host,$port)}sub format_hostport($;$) {my ($host,$port)=@_;$port=":$port" if length$port;$host="[$host]" if$host =~ /:/;"$host$port"}sub address_family($) {4==length $_[0]? AF_INET : 16==length $_[0]? AF_INET6 : unpack "S",$_[0]}sub format_ipv4($) {join ".",unpack "C4",$_[0]}sub format_ipv6($) {if ($_[0]=~ /^\x00\x00\x00\x00\x00\x00\x00\x00/){if (v0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0 eq $_[0]){return "::"}elsif (v0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.1 eq $_[0]){return "::1"}elsif (v0.0.0.0.0.0.0.0.0.0.0.0 eq substr $_[0],0,12){return "::" .format_ipv4 substr $_[0],12}elsif (v0.0.0.0.0.0.0.0.0.0.255.255 eq substr $_[0],0,12){return "::ffff:" .format_ipv4 substr $_[0],12}elsif (v0.0.0.0.0.0.0.0.255.255.0.0 eq substr $_[0],0,12){return "::ffff:0:" .format_ipv4 substr $_[0],12}}my$ip=sprintf "%x:%x:%x:%x:%x:%x:%x:%x",unpack "n8",$_[0];$ip =~ s/(?:^|:) 0:0:0:0:0:0:0 (?:$|:)/::/x or $ip =~ s/(?:^|:)   0:0:0:0:0:0 (?:$|:)/::/x or $ip =~ s/(?:^|:)     0:0:0:0:0 (?:$|:)/::/x or $ip =~ s/(?:^|:)       0:0:0:0 (?:$|:)/::/x or $ip =~ s/(?:^|:)         0:0:0 (?:$|:)/::/x or $ip =~ s/(?:^|:)           0:0 (?:$|:)/::/x;$ip}sub format_address($) {if (4==length $_[0]){return&format_ipv4}elsif (16==length $_[0]){return $_[0]=~ /^\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\xff(....)$/s ? format_ipv4 $1 : &format_ipv6}elsif (AF_UNIX==address_family $_[0]){return "unix/"}else {return undef}}*ntoa=\&format_address;sub inet_aton {my ($name,$cb)=@_;if (my$ipn=&parse_ipv4){$cb->($ipn)}elsif (my$ipn=&parse_ipv6){$cb->($ipn)}elsif ($name eq "localhost"){$cb->(v127.0.0.1,v0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.1)}else {require AnyEvent::DNS unless$AnyEvent::DNS::VERSION;my$ipv4=$AnyEvent::PROTOCOL{ipv4};my$ipv6=$AnyEvent::PROTOCOL{ipv6};my@res;my$cv=AE::cv {$cb->(map @$_,reverse@res)};$cv->begin;if ($ipv4){$cv->begin;AnyEvent::DNS::a ($name,sub {$res[$ipv4]=[map {parse_ipv4 $_}@_];$cv->end})};if ($ipv6){$cv->begin;AnyEvent::DNS::aaaa ($name,sub {$res[$ipv6]=[map {parse_ipv6 $_}@_];$cv->end})};$cv->end}}BEGIN {*sockaddr_family=$Socket::VERSION >= 1.75 ? \&Socket::sockaddr_family : (Socket::pack_sockaddr_in 0x5555,"\x55\x55\x55\x55" | eval {Socket::pack_sockaddr_un "U"})=~ /^\x00/ ? sub {unpack "xC",$_[0]}: sub {unpack "S",$_[0]}}my$pack_family=0x55==sockaddr_family ("\x55\x55")? "xC" : "S";sub pack_sockaddr($$) {my$af=address_family $_[1];if ($af==AF_INET){Socket::pack_sockaddr_in $_[0],$_[1]}elsif ($af==AF_INET6){pack "$pack_family nL a16 L",AF_INET6,$_[0],0,$_[1],0}elsif ($af==AF_UNIX){Socket::pack_sockaddr_un $_[0]}else {Carp::croak "pack_sockaddr: invalid host"}}my$sa_un_zero=$Socket::VERSION >= 2.011 ? "" : eval {Socket::pack_sockaddr_un ""};$sa_un_zero ^= $sa_un_zero;sub unpack_sockaddr($) {my$af=sockaddr_family $_[0];if ($af==AF_INET){Socket::unpack_sockaddr_in $_[0]}elsif ($af==AF_INET6){unpack "x2 n x4 a16",$_[0]}elsif ($af==AF_UNIX){((Socket::unpack_sockaddr_un $_[0]^ $sa_un_zero),pack "S",AF_UNIX)}else {Carp::croak "unpack_sockaddr: unsupported protocol family $af"}}our%HOSTS;our@HOSTS_CHECKING;our$HOSTS_MTIME;sub _parse_hosts($) {%HOSTS=();for (split /\n/,$_[0]){s/#.*$//;s/^[ \t]+//;y/A-Z/a-z/;my ($addr,@aliases)=split /[ \t]+/;next unless@aliases;if (my$ip=parse_ipv4$addr){($ip)=$ip =~ /^(.*)$/s if AnyEvent::TAINT;push @{$HOSTS{$_}[0]},$ip for@aliases}elsif (my$ip=parse_ipv6$addr){($ip)=$ip =~ /^(.*)$/s if AnyEvent::TAINT;push @{$HOSTS{$_}[1]},$ip for@aliases}}}sub _load_hosts_unless(&$@) {my ($cont,$cv,@dns)=@_;if (@dns){$cv->end}else {my$etc_hosts=length$ENV{PERL_ANYEVENT_HOSTS}? $ENV{PERL_ANYEVENT_HOSTS}: AnyEvent::WIN32 ? "$ENV{SystemRoot}/system32/drivers/etc/hosts" : "/etc/hosts";push@HOSTS_CHECKING,sub {$cont->();$cv->end};unless ($#HOSTS_CHECKING){require AnyEvent::IO;AnyEvent::IO::aio_stat ($etc_hosts,sub {if ((stat _)[9]ne $HOSTS_MTIME){AE::log 8=>"(re)loading $etc_hosts.";$HOSTS_MTIME=(stat _)[9];AnyEvent::IO::aio_load ($etc_hosts,sub {_parse_hosts $_[0];(shift@HOSTS_CHECKING)->()while@HOSTS_CHECKING})}else {(shift@HOSTS_CHECKING)->()while@HOSTS_CHECKING}})}}}sub resolve_sockaddr($$$$$$) {my ($node,$service,$proto,$family,$type,$cb)=@_;if ($node eq "unix/"){return$cb->()if$family || $service !~ /^\//;return$cb->([AF_UNIX,defined$type ? $type : SOCK_STREAM,0,Socket::pack_sockaddr_un$service])}unless (AF_INET6){$family!=6 or return$cb->();$family=4}$cb->()if$family==4 &&!$AnyEvent::PROTOCOL{ipv4};$cb->()if$family==6 &&!$AnyEvent::PROTOCOL{ipv6};$family ||= 4 unless$AnyEvent::PROTOCOL{ipv6};$family ||= 6 unless$AnyEvent::PROTOCOL{ipv4};$proto ||= "tcp";$type ||= $proto eq "udp" ? SOCK_DGRAM : SOCK_STREAM;my$proton=AnyEvent::Socket::getprotobyname$proto or Carp::croak "$proto: protocol unknown";my$port;if ($service =~ /^(\S+)=(\d+)$/){($service,$port)=($1,$2)}elsif ($service =~ /^\d+$/){($service,$port)=(undef,$service)}else {$port=(getservbyname$service,$proto)[2]or Carp::croak "$service/$proto: service unknown"}my$resolve=sub {my@target=@_;my@res;my$cv=AE::cv {$cb->(map $_->[2],sort {$AnyEvent::PROTOCOL{$b->[1]}<=> $AnyEvent::PROTOCOL{$a->[1]}or $a->[0]<=> $b->[0]}@res)};$cv->begin;for my$idx (0 .. $#target){my ($node,$port)=@{$target[$idx]};if (my$noden=parse_address$node){my$af=address_family$noden;if ($af==AF_INET && $family!=6){push@res,[$idx,"ipv4",[AF_INET,$type,$proton,pack_sockaddr$port,$noden]]}if ($af==AF_INET6 && $family!=4){push@res,[$idx,"ipv6",[AF_INET6,$type,$proton,pack_sockaddr$port,$noden]]}}else {$node =~ y/A-Z/a-z/;if ($family!=6){$cv->begin;AnyEvent::DNS::a$node,sub {push@res,[$idx,"ipv4",[AF_INET,$type,$proton,pack_sockaddr$port,parse_ipv4 $_]]for @_;_load_hosts_unless {push@res,map [$idx,"ipv4",[AF_INET,$type,$proton,pack_sockaddr$port,$_]],@{($HOSTS{$node}|| [])->[0]}}$cv,@_}}if ($family!=4){$cv->begin;AnyEvent::DNS::aaaa$node,sub {push@res,[$idx,"ipv6",[AF_INET6,$type,$proton,pack_sockaddr$port,parse_ipv6 $_]]for @_;_load_hosts_unless {push@res,map [$idx + 0.5,"ipv6",[AF_INET6,$type,$proton,pack_sockaddr$port,$_]],@{($HOSTS{$node}|| [])->[1]}}$cv,@_}}}}$cv->end};$node=AnyEvent::Util::idn_to_ascii$node if$node =~ /[^\x00-\x7f]/;if ($node eq "localhost"){$resolve->(["127.0.0.1",$port],["::1",$port])}elsif (defined$service &&!parse_address$node){AnyEvent::DNS::srv$service,$proto,$node,sub {my (@srv)=@_;if (@srv){$srv[0][2]ne "" || $#srv or return$cb->();$resolve->(map ["$_->[3].",$_->[2]],grep $_->[3]ne ".",@srv)}else {$resolve->([$node,$port])}}}else {$resolve->([$node,$port])}}sub tcp_connect($$$;$) {my ($host,$port,$connect,$prepare)=@_;my%state=(fh=>undef);resolve_sockaddr$host,$port,0,0,undef,sub {my@target=@_;$state{next}=sub {return unless exists$state{fh};my$errno=$!;my$target=shift@target or return AE::postpone {return unless exists$state{fh};%state=();$!=$errno;$connect->()};my ($domain,$type,$proto,$sockaddr)=@$target;socket$state{fh},$domain,$type,$proto or return$state{next}();AnyEvent::fh_unblock$state{fh};my$timeout=$prepare && $prepare->($state{fh});$timeout ||= 30 if AnyEvent::WIN32;$state{to}=AE::timer$timeout,0,sub {$!=Errno::ETIMEDOUT;$state{next}()}if$timeout;if ((connect$state{fh},$sockaddr)|| ($!==Errno::EINPROGRESS || $!==Errno::EWOULDBLOCK || $!==AnyEvent::Util::WSAEINVAL || $!==AnyEvent::Util::WSAEWOULDBLOCK)){$state{ww}=AE::io$state{fh},1,sub {if (my$sin=getpeername$state{fh}){my ($port,$host)=unpack_sockaddr$sin;delete$state{ww};delete$state{to};my$guard=guard {%state=()};$connect->(delete$state{fh},format_address$host,$port,sub {$guard->cancel;$state{next}()})}else {if ($!==Errno::ENOTCONN){sysread$state{fh},my$buf,1;$!=(unpack "l",getsockopt$state{fh},Socket::SOL_SOCKET(),Socket::SO_ERROR())|| Errno::EAGAIN if AnyEvent::CYGWIN && $!==Errno::EAGAIN}return if $!==Errno::EAGAIN;delete$state{ww};delete$state{to};$state{next}()}}}else {$state{next}()}};$!=Errno::ENXIO;$state{next}()};defined wantarray && guard {%state=()}}sub _tcp_bind($$$;$) {my ($host,$service,$done,$prepare)=@_;$host=$AnyEvent::PROTOCOL{ipv4}< $AnyEvent::PROTOCOL{ipv6}&& AF_INET6 ? "::" : "0" unless defined$host;my$ipn=parse_address$host or Carp::croak "AnyEvent::Socket::tcp_server: cannot parse '$host' as host address";my$af=address_family$ipn;my%state;Carp::croak "tcp_server/socket: address family not supported" if AnyEvent::WIN32 && $af==AF_UNIX;socket$state{fh},$af,SOCK_STREAM,0 or Carp::croak "tcp_server/socket: $!";if ($af==AF_INET || $af==AF_INET6){setsockopt$state{fh},SOL_SOCKET,SO_REUSEADDR,1 or Carp::croak "tcp_server/so_reuseaddr: $!" unless AnyEvent::WIN32;unless ($service =~ /^\d*$/){$service=(getservbyname$service,"tcp")[2]or Carp::croak "$service: service unknown"}}elsif ($af==AF_UNIX){unlink$service}bind$state{fh},pack_sockaddr$service,$ipn or Carp::croak "bind: $!";if ($af==AF_UNIX){my$fh=$state{fh};my$ino=(stat$fh)[1];$state{unlink}=guard {unlink$service if$ino==(stat$fh)[1]}}AnyEvent::fh_unblock$state{fh};my$len;if ($prepare){my ($service,$host)=unpack_sockaddr getsockname$state{fh};$len=$prepare && $prepare->($state{fh},format_address$host,$service)}$len ||= 128;listen$state{fh},$len or Carp::croak "listen: $!";$done->(\%state);defined wantarray ? guard {%state=()}: ()}sub tcp_bind($$$;$) {my ($host,$service,$done,$prepare)=@_;_tcp_bind$host,$service,sub {$done->(delete shift->{fh})},$prepare}sub tcp_server($$$;$) {my ($host,$service,$accept,$prepare)=@_;_tcp_bind$host,$service,sub {my$rstate=shift;$rstate->{aw}=AE::io$rstate->{fh},0,sub {while ($rstate->{fh}&& (my$peer=accept my$fh,$rstate->{fh})){AnyEvent::fh_unblock$fh;my ($service,$host)=unpack_sockaddr$peer;$accept->($fh,format_address$host,$service)}}},$prepare}sub tcp_nodelay($$) {my$onoff=int!!$_[1];setsockopt $_[0],Socket::IPPROTO_TCP (),Socket::TCP_NODELAY (),$onoff}sub tcp_congestion($$) {defined TCP_CONGESTION ? setsockopt $_[0],Socket::IPPROTO_TCP (),TCP_CONGESTION,"$_[1]" : undef}1
ANYEVENT_SOCKET

$fatpacked{"AnyEvent/Strict.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_STRICT';
  package AnyEvent::Strict;use Carp qw(confess);use Errno ();use POSIX ();$Carp::Internal{AE}=1;$Carp::Internal{AnyEvent::Strict}=1;use AnyEvent ();BEGIN {AnyEvent::common_sense}AnyEvent::_isa_hook 1=>"AnyEvent::Strict",1;BEGIN {if (defined&Internals::SvREADONLY){*wrap=sub {my$cb=shift;sub {local $_;Internals::SvREADONLY $_,1;&$cb}}}else {my$magic=[];*wrap=sub {my$cb=shift;sub {local $_=$magic;&$cb;if (!ref $_ || $_!=$magic){require AnyEvent::Debug;die "callback $cb (" .AnyEvent::Debug::cb2str ($cb).") modified \$_ without restoring it.\n"}}}}}our (@FD_INUSE,$FD_I);our$FD_CHECK_W=AE::timer 4,4,sub {my$cnt=(@FD_INUSE < 100 * 10 ? int@FD_INUSE * 0.1 : 100)|| 10;if ($FD_I <= 0){$FD_I=@FD_INUSE or return}$cnt=$FD_I if$cnt > $FD_I;eval {do {!$FD_INUSE[--$FD_I]or (POSIX::lseek$FD_I,0,1)!=-1 or $!!=Errno::EBADF or die}while --$cnt;1}or AE::log crit=>"File descriptor $FD_I registered with AnyEvent but prematurely closed, event loop might malfunction."};sub io {my$class=shift;my (%arg,$fh,$cb,$fd)=@_;ref$arg{cb}or confess "AnyEvent->io called with illegal cb argument '$arg{cb}'";$cb=wrap delete$arg{cb};$arg{poll}=~ /^[rw]$/ or confess "AnyEvent->io called with illegal poll argument '$arg{poll}'";$fh=delete$arg{fh};if ($fh =~ /^\s*\d+\s*$/){$fd=$fh;$fh=AnyEvent::_dupfh$arg{poll},$fh}else {defined eval {$fd=fileno$fh}or confess "AnyEvent->io called with illegal fh argument '$fh'"}-f$fh and confess "AnyEvent->io called with fh argument pointing to a file";delete$arg{poll};confess "AnyEvent->io called with unsupported parameter(s) " .join ", ",keys%arg if keys%arg;++$FD_INUSE[$fd];bless [$fd,$class->SUPER::io (@_,cb=>$cb)],"AnyEvent::Strict::io"}sub AnyEvent::Strict::io::DESTROY {--$FD_INUSE[$_[0][0]]}sub timer {my$class=shift;my%arg=@_;ref$arg{cb}or confess "AnyEvent->timer called with illegal cb argument '$arg{cb}'";my$cb=wrap delete$arg{cb};exists$arg{after}or confess "AnyEvent->timer called without mandatory 'after' parameter";delete$arg{after};!$arg{interval}or $arg{interval}> 0 or confess "AnyEvent->timer called with illegal interval argument '$arg{interval}'";delete$arg{interval};confess "AnyEvent->timer called with unsupported parameter(s) " .join ", ",keys%arg if keys%arg;$class->SUPER::timer (@_,cb=>$cb)}sub signal {my$class=shift;my%arg=@_;ref$arg{cb}or confess "AnyEvent->signal called with illegal cb argument '$arg{cb}'";my$cb=wrap delete$arg{cb};defined AnyEvent::Base::sig2num$arg{signal}and $arg{signal}==0 or confess "AnyEvent->signal called with illegal signal name '$arg{signal}'";delete$arg{signal};confess "AnyEvent->signal called with unsupported parameter(s) " .join ", ",keys%arg if keys%arg;$class->SUPER::signal (@_,cb=>$cb)}sub child {my$class=shift;my%arg=@_;ref$arg{cb}or confess "AnyEvent->child called with illegal cb argument '$arg{cb}'";my$cb=wrap delete$arg{cb};$arg{pid}=~ /^-?\d+$/ or confess "AnyEvent->child called with malformed pid value '$arg{pid}'";delete$arg{pid};confess "AnyEvent->child called with unsupported parameter(s) " .join ", ",keys%arg if keys%arg;$class->SUPER::child (@_,cb=>$cb)}sub idle {my$class=shift;my%arg=@_;ref$arg{cb}or confess "AnyEvent->idle called with illegal cb argument '$arg{cb}'";my$cb=wrap delete$arg{cb};confess "AnyEvent->idle called with unsupported parameter(s) " .join ", ",keys%arg if keys%arg;$class->SUPER::idle (@_,cb=>$cb)}sub condvar {my$class=shift;my%arg=@_;!exists$arg{cb}or ref$arg{cb}or confess "AnyEvent->condvar called with illegal cb argument '$arg{cb}'";my@cb=exists$arg{cb}? (cb=>wrap delete$arg{cb}): ();confess "AnyEvent->condvar called with unsupported parameter(s) " .join ", ",keys%arg if keys%arg;$class->SUPER::condvar (@cb)}sub time {my$class=shift;@_ and confess "AnyEvent->time wrongly called with paramaters";$class->SUPER::time (@_)}sub now {my$class=shift;@_ and confess "AnyEvent->now wrongly called with paramaters";$class->SUPER::now (@_)}1
ANYEVENT_STRICT

$fatpacked{"AnyEvent/TLS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_TLS';
  package AnyEvent::TLS;use Carp qw(croak);use Scalar::Util ();use AnyEvent ();BEGIN {AnyEvent::common_sense}use AnyEvent::Util ();use Net::SSLeay;our$VERSION=$AnyEvent::VERSION;our$REF_IDX;sub _tmpfile($) {require File::Temp unless$File::Temp::VERSION;my ($fh,$path)=File::Temp::tempfile ("aetlsXXXXXXXXX",TMPDIR=>1,EXLOCK=>0);my$guard=AnyEvent::Util::guard {unlink$path};syswrite$fh,$_[0];close$fh;($path,$guard)}our%DH_PARAMS=(skip512=>"MEYCQQD1Kv884bEpQBgRjXyEpwpy1obEAxnIByl6ypUM2Zafq9AKUJsCRtMIPWak|XUGfnHy9iUsiGSa6q6Jew1XpKgVfAgEC",skip1024=>"MIGHAoGBAPSI/VhOSdvNILSd5JEHNmszbDgNRR0PfIizHHxbLY7288kjwEPwpVsY|jY67VYy4XTjTNP18F1dDox0YbN4zISy1Kv884bEpQBgRjXyEpwpy1obEAxnIByl6|ypUM2Zafq9AKUJsCRtMIPWakXUGfnHy9iUsiGSa6q6Jew1XpL3jHAgEC",skip2048=>"MIIBCAKCAQEA9kJXtwh/CBdyorrWqULzBej5UxE5T7bxbrlLOCDaAadWoxTpj0BV|89AHxstDqZSt90xkhkn4DIO9ZekX1KHTUPj1WV/cdlJPPT2N286Z4VeSWc39uK50|T8X8dryDxUcwYc58yWb/Ffm7/ZFexwGq01uejaClcjrUGvC/RgBYK+X0iP1YTknb|zSC0neSRBzZrM2w4DUUdD3yIsxx8Wy2O9vPJI8BD8KVbGI2Ou1WMuF040zT9fBdX|Q6MdGGzeMyEstSr/POGxKUAYEY18hKcKctaGxAMZyAcpesqVDNmWn6vQClCbAkbT|CD1mpF1Bn5x8vYlLIhkmuquiXsNV6TILOwIBAg==",skip4096=>"MIICCAKCAgEA+hRyUsFN4VpJ1O8JLcCo/VWr19k3BCgJ4uk+d+KhehjdRqNDNyOQ|l/MOyQNQfWXPeGKmOmIig6Ev/nm6Nf9Z2B1h3R4hExf+zTiHnvVPeRBhjdQi81rt|Xeoh6TNrSBIKIHfUJWBh3va0TxxjQIs6IZOLeVNRLMqzeylWqMf49HsIXqbcokUS|Vt1BkvLdW48j8PPv5DsKRN3tloTxqDJGo9tKvj1Fuk74A+Xda1kNhB7KFlqMyN98|VETEJ6c7KpfOo30mnK30wqw3S8OtaIR/maYX72tGOno2ehFDkq3pnPtEbD2CScxc|alJC+EL7RPk5c/tgeTvCngvc1KZn92Y//EI7G9tPZtylj2b56sHtMftIoYJ9+ODM|sccD5Piz/rejE3Ome8EOOceUSCYAhXn8b3qvxVI1ddd1pED6FHRhFvLrZxFvBEM9|ERRMp5QqOaHJkM+Dxv8Cj6MqrCbfC4u+ZErxodzuusgDgvZiLF22uxMZbobFWyte|OvOzKGtwcTqO/1wV5gKkzu1ZVswVUQd5Gg8lJicwqRWyyNRczDDoG9jVDxmogKTH|AaqLulO7R8Ifa1SwF2DteSGVtgWEN8gDpN3RBmmPTDngyF2DHb5qmpnznwtFKdTL|KWbuHn491xNO25CQWMtem80uKw+pTnisBRF/454n1Jnhub144YRBoN8CAQI=",schmorp1024=>"MIGHAoGBAN+GjqAhNxLesSuGfDzYe6HdexXtHuxe85umshfPHfnmLSkGWl/FE27+|v+50mwY5XaNnCmo1VvGju4iTKxWoZTGgslUSc8KX197XWAXIpab8ESyg442if9Kr|vSOuu0fopwvvTOgHK8mkEWI4joU5G4/MQy+pnC5NIEVBP4HtGiTrAgEC",schmorp1539=>"MIHHAoHBByJzpVGUsXysX8w/+uuXRUCL9exhAixoHkaJU5lf4noJUtp9F0yr/5rb|hF8M9mSZJ+RlPyB+Zt37GPp1WQDO1+/2yZJX9kHE3+h5JCRoR8PKc2G+ts9jhM7r|CnTQ0z0b6s12Pusf+UhQPwLust4JAYE/LPuTK8yFiVx5L2a+aZhGMVlYN/12SEtY|jRl3lGXdZj9g8E2PzTQbA9CGy5dGIvz/ENTzTVleKuQ+80bzpVEPjZL9tv43Zc+l|MFLzxuE5uwIBAg==",schmorp2048=>"MIIBCAKCAQEAhR5Fn9h3Tgnc+q4o3CMkZtre3lLUyDT+1bf3aiVOt22JdDQndZLc|FeKz8AqliB3UIgNExc6oDtuG4znKPgklfOnHv/a9tl1AYQbV+QFM/E0jYl6oG8tF|Epgxezt1GCivvtu64ql0s213wr64QffNMt3hva8lNqK1PXfqp13PzzLzAVsfghrv|fMAX7/bYm1T5fAJdcah6FeZkKof+mqbs8HtRjfvrUF2npEM2WdupFu190vcwABnN|TTJheXCWv2BF2f9EEr61q3OUhSNWIThtZP+NKe2bACm1PebT0drAcaxKoMz9LjKr|y5onGs0TOuQ7JmhtZL45Zr4LwBcyTucLUwIBAg==",schmorp4096=>"MIICCAKCAgEA5WwA5lQg09YRYqc/JILCd2AfBmYBkF19wmCEJB8G3JhTxv8EGvYk|xyP2ecKVUvHTG8Xw/qpW8nRqzPIyV8QRf6YFYSf33Qnx2xYhcnqOumU3nfC0SNOL|/w2q1BA9BbHtW4574P+6hOQx9ftRtbtZ2HPKBMRcAKGjpYZiKopv0+UAM4NpEC2p|bfajp7pyVLeb/Aqm/oWP3L63wPlY1SDp+XRzrOAKB+/uLGqEwV0bBaxxGL29BpOp|O2z1ALGXiDCcLs9WTn9WqUhWDzUN6fahm53rd7zxwpFCb6K2YhaK0peG95jzSUJ8|aoL0KgWuC6v5+gPJHRu0HrQIdfAdN4VchqYOKE46uNNkQl8VJGu4RjYB7lFBpRwO|g2HCsGMo2X7BRmA1st66fh+JOd1smXMZG/2ozTOooL+ixcx4spNneg4aQerWl5cb|nWXKtPCp8yPzt/zoNzL3Fon2Ses3sNgMos0M/ZbnigScDxz84Ms6V/X8Z0L4m/qX|mL42dP40tgvmgqi6BdsBzcIWeHlEcIhmGcsEBxxKEg7gjb0OjjvatpUCJhmRrGjJ|LtMkBR68qr42OBMN/PBB4KPOWNUqTauXZajfCwYdbpvV24ZhtkcRdw1zisyARBSh|aTKW/GV8iLsUzlYN27LgVEwMwnWQaoecW6eOTNKGUURC3In6XZSvVzsCAQI=",schmorp8192=>"MIIECAKCBAEA/SAEbRSSLenVxoInHiltm/ztSwehGOhOiUKfzDcKlRBZHlCC9jBl|S/aeklM6Ucg8E6J2bnfoh6CAdnE/glQOn6CifhZr8X/rnlL9/eP+r9m+aiAw4l0D|MBd8BondbEqwTZthMmLtx0SslnevsFAZ1Cj8WgmUNaSPOukvJ1N7aQ98U+E99Pw3|VG8ANBydXqLqW2sogS8FtZoMbVywcQuaGmC7M6i3Akxe3CCSIpR/JkEZIytREBSC|CH+x3oW/w+wHzq3w8DGB9hqz1iMXqDMiPIMSdXC0DaIPokLnd7X8u6N14yCAco2h|P0gspD3J8pS2FpUY8ZTVjzbVCjhNNmTryBZAxHSWBuX4xYcCHUtfGlUe/IGLSVE1|xIdFpZUfvlvAJjVq0/TtDMg3r2JSXrhQVlr8MPJwSApDVr5kOBHT/uABio4z+5yR|PAvundznfyo9GGAWhIA36GQqsxSQfoRTjWssFoR/cu+9aomRwwOLkvObu8nCVVLH|nLdKDk5cIR0TvNs9HZ6ZmkzL7ah7cPzEKl7U6eE6yZLVYMNecnPLS6PSAIG4gxcq|CVQrrZjQLfTDrJn0OGgpShX85RaDsuiRtp2bpDZ23YDqdwr4wRjvIargjqc2zcF+|jIb7dUS6ci7bVG/CGOQUuiMWAiXZ3a1f343SMf9A05/sf1xwnMeco6STBLZ3X+PA|4urU+grtpWaFtS/fPD2ILn8nrJ3WuSKKUeSnVM46mmJQsOkyn7z8l3jNLB17GYKo|qc+0UuU/2PM9qtZdZElSM/ACLV2vdCuaibop4B9UIP9z3F8kfZ72+zKxpGiE+Bo1|x8SfG8FQw90mYIx+qZzJ8MCvc2wh+l4wDX5KxrhwvcouE2tHQlwfDgv/DiIXp173|hAmUCV0+bPRW8IIJvBODdAWtJe9hNwxj1FFYmPA7l4wa3gXV4I6tb+iO1MbwVjZ/|116tD5MdCo3JuSisgPYCHfkQccwEO0FHEuBbmfN+fQimQ8H0dePP8XctwbkplsB+|aLT5hYKmva/j9smEswgyHglPwc3WvZ+2DgKk7A7DHi7a2gDwCRQlHaXtNWx3992R|dfNgkSeB1CvGSQoo95WpC9ZoqGmcSlVqdetDU8iglPmfYTKO8aIPA6TuTQ/lQ0IW|90LQmqP23FwnNFiyqX8+rztLq4KVkTyeHIQwig6vFxgD8N+SbZCW2PPiB72TVF2U|WePU8MRTv1OIGBUBajF49k28HnZPSGlILHtFEkYkbPvomcE5ENnoejwzjktOTS5d|/R3SIOvCauOzadtzwTYOXT78ORaR1KI1cm8DzkkwJTd/Rrk07Q5vnvnSJQMwFUeH|PwJIgWBQf/GZ/OsDHmkbYR2ZWDClbKw2mwIBAg==",);sub init ();BEGIN {eval 'sub _check_tls_gt_1 (){' .(($Net::SSLeay::VERSION >= 1.55 && Net::SSLeay::OPENSSL_VERSION_NUMBER()>= 0x1000100f)* 1).'}'}our%SSL_METHODS=(any=>\&Net::SSLeay::CTX_new,sslv23=>\&Net::SSLeay::CTX_new,sslv2=>\&Net::SSLeay::CTX_v2_new,sslv3=>\&Net::SSLeay::CTX_v3_new,tlsv1=>\&Net::SSLeay::CTX_tlsv1_new,);if (_check_tls_gt_1){$SSL_METHODS{tlsv1_1}=\&Net::SSLeay::CTX_tlsv1_1_new;$SSL_METHODS{tlsv1_2}=\&Net::SSLeay::CTX_tlsv1_2_new}else {for my$method (qw(tlsv1_1 tlsv1_2)){$SSL_METHODS{$method}=sub {croak "AnyEvent::TLS method '$method' requires openssl v1.0.1 and Net::SSLeay 1.55 or higher"}}}sub new {my ($class,%arg)=@_;init unless$REF_IDX;my$method=lc$arg{method}|| "any";my$ctx=($SSL_METHODS{$method}|| croak "'$method' is not a valid AnyEvent::TLS method (must be one of @{[ sort keys %SSL_METHODS ]})")->();my$self=bless {ctx=>$ctx },$class;my$op=Net::SSLeay::OP_ALL ();$op |= Net::SSLeay::OP_NO_SSLv2 ()unless$arg{sslv2};$op |= Net::SSLeay::OP_NO_SSLv3 ()if exists$arg{sslv3}&&!$arg{sslv3};$op |= Net::SSLeay::OP_NO_TLSv1 ()if exists$arg{tlsv1}&&!$arg{tlsv1};$op |= Net::SSLeay::OP_NO_TLSv1_1 ()if exists$arg{tlsv1_1}&&!$arg{tlsv1_1}&& _check_tls_gt_1;$op |= Net::SSLeay::OP_NO_TLSv1_2 ()if exists$arg{tlsv1_2}&&!$arg{tlsv1_2}&& _check_tls_gt_1;$op |= Net::SSLeay::OP_SINGLE_DH_USE ()if!exists$arg{dh_single_use}|| $arg{dh_single_use};Net::SSLeay::CTX_set_options ($ctx,$op);Net::SSLeay::CTX_set_cipher_list ($ctx,$arg{cipher_list})or croak "'$arg{cipher_list}' was not accepted as a valid cipher list by AnyEvent::TLS" if exists$arg{cipher_list};my ($dh_bio,$dh_file);if (exists$arg{dh_file}){$dh_file=$arg{dh_file};$dh_bio=Net::SSLeay::BIO_new_file ($dh_file,"r")or croak "$dh_file: failed to open DH parameter file: $!"}else {$arg{dh}="schmorp1539" unless exists$arg{dh};if (defined$arg{dh}){$dh_file="dh string";if ($arg{dh}=~ /^\w+$/){$dh_file="dh params $arg{dh}";$arg{dh}="-----BEGIN DH PARAMETERS-----\n" .$DH_PARAMS{$arg{dh}}."\n" ."-----END DH PARAMETERS-----";$arg{dh}=~ s/\|/\n/g}$dh_bio=Net::SSLeay::BIO_new (Net::SSLeay::BIO_s_mem ());Net::SSLeay::BIO_write ($dh_bio,$arg{dh})}}if ($dh_bio){my$dh=Net::SSLeay::PEM_read_bio_DHparams ($dh_bio);Net::SSLeay::BIO_free ($dh_bio);$dh or croak "$dh_file: failed to parse DH parameters - not PEM format?";my$rv=Net::SSLeay::CTX_set_tmp_dh ($ctx,$dh);Net::SSLeay::DH_free ($dh);$rv or croak "$dh_file: failed to set DH parameters"}if ($arg{verify}){$self->{verify_mode}=Net::SSLeay::VERIFY_PEER ();$self->{verify_mode}|= Net::SSLeay::VERIFY_FAIL_IF_NO_PEER_CERT ()if$arg{verify_require_client_cert};$self->{verify_mode}|= Net::SSLeay::VERIFY_CLIENT_ONCE ()if$arg{verify_client_once}}else {$self->{verify_mode}=Net::SSLeay::VERIFY_NONE ()}$self->{verify_peername}=$arg{verify_peername}if exists$arg{verify_peername};$self->{verify_cb}=$arg{verify_cb}if exists$arg{verify_cb};$self->{session_ticket}=$arg{session_ticket}if exists$arg{session_ticket};$self->{debug}=$ENV{PERL_ANYEVENT_TLS_DEBUG}if length$ENV{PERL_ANYEVENT_TLS_DEBUG};$self->{debug}=$arg{debug}if exists$arg{debug};my$pw=$arg{cert_password};Net::SSLeay::CTX_set_default_passwd_cb ($ctx,ref$pw ? $pw : sub {$pw});if ($self->{verify_mode}){if (exists$arg{ca_file}or exists$arg{ca_path}or exists$arg{ca_cert}){if (exists$arg{ca_cert}){my ($ca_file,$g1)=_tmpfile delete$arg{ca_cert};Net::SSLeay::CTX_load_verify_locations ($ctx,$ca_file,undef)}if (exists$arg{ca_file}or exists$arg{ca_path}){Net::SSLeay::CTX_load_verify_locations ($ctx,$arg{ca_file},$arg{ca_path})}}elsif (length$ENV{PERL_ANYEVENT_CA_FILE}or length$ENV{PERL_ANYEVENT_CA_PATH}){Net::SSLeay::CTX_load_verify_locations ($ctx,$ENV{PERL_ANYEVENT_CA_FILE},$ENV{PERL_ANYEVENT_CA_PATH},)}else {Net::SSLeay::CTX_set_default_verify_paths ($ctx)}}if (exists$arg{cert}or exists$arg{cert_file}){my ($g1,$g2);if (exists$arg{cert}){croak "specifying both cert_file and cert is not allowed" if exists$arg{cert_file};($arg{cert_file},$g1)=_tmpfile delete$arg{cert}}if (exists$arg{key}or exists$arg{key_file}){if (exists$arg{key}){croak "specifying both key_file and key is not allowed" if exists$arg{key_file};($arg{key_file},$g2)=_tmpfile delete$arg{key}}}else {$arg{key_file}=$arg{cert_file}}Net::SSLeay::CTX_use_PrivateKey_file ($ctx,$arg{key_file},Net::SSLeay::FILETYPE_PEM ())or croak "$arg{key_file}: failed to load local private key (key_file or key)";Net::SSLeay::CTX_use_certificate_chain_file ($ctx,$arg{cert_file})or croak "$arg{cert_file}: failed to use local certificate chain (cert_file or cert)"}if ($arg{check_crl}){Net::SSLeay::OPENSSL_VERSION_NUMBER ()>= 0x00090702f or croak "check_crl requires openssl v0.9.7b or higher";Net::SSLeay::X509_STORE_set_flags (Net::SSLeay::CTX_get_cert_store ($ctx),Net::SSLeay::X509_V_FLAG_CRL_CHECK ())}Net::SSLeay::CTX_set_read_ahead ($ctx,1);$arg{prepare}->($self)if$arg{prepare};$self}sub new_from_ssleay {my ($class,$ctx)=@_;bless {ctx=>$ctx },$class}sub ctx {$_[0]{ctx}}sub verify_hostname($$$);sub _verify_hostname {my ($self,$cn,$cert)=@_;return 1 unless defined$cn;return 1 unless exists$self->{verify_peername}&& "none" ne lc$self->{verify_peername};return$self->{verify_peername}->($self,$cn,$cert)if ref$self->{verify_peername}&& "ARRAY" ne ref$self->{verify_peername};verify_hostname$cn,$cert,$self->{verify_peername}}sub verify {my ($self,$session,$ref,$cn,$preverify_ok,$x509_store_ctx)=@_;my$cert=$x509_store_ctx ? Net::SSLeay::X509_STORE_CTX_get_current_cert ($x509_store_ctx): undef;my$depth=Net::SSLeay::X509_STORE_CTX_get_error_depth ($x509_store_ctx);$preverify_ok &&= $self->_verify_hostname ($cn,$cert)unless$depth;$preverify_ok=$self->{verify_cb}->($self,$ref,$cn,$depth,$preverify_ok,$x509_store_ctx,$cert)if$self->{verify_cb};$preverify_ok}sub _get_session($$;$$) {my ($self,$mode,$ref,$cn)=@_;my$session;if ($mode eq "accept"){$session=Net::SSLeay::new ($self->{ctx});Net::SSLeay::set_accept_state ($session);Net::SSLeay::set_options ($session,eval {Net::SSLeay::OP_NO_TICKET ()})unless$self->{session_ticket}||!exists$self->{session_ticket}}elsif ($mode eq "connect"){$session=Net::SSLeay::new ($self->{ctx});Net::SSLeay::set_connect_state ($session);Net::SSLeay::set_options ($session,eval {Net::SSLeay::OP_NO_TICKET ()})unless$self->{session_ticket}}else {croak "'$mode': unsupported TLS mode (must be either 'connect' or 'accept')"}if ($self->{debug}){}if ($self->{verify_mode}){Scalar::Util::weaken$self;Scalar::Util::weaken$ref;Net::SSLeay::set_verify $session,$self->{verify_mode},sub {$self->verify ($session,$ref,$cn,@_)}}$session}sub _put_session($$) {my ($self,$session)=@_;Net::SSLeay::set_verify$session,0,undef;Net::SSLeay::free ($session)}sub DESTROY {my ($self)=@_;Net::SSLeay::CTX_set_default_passwd_cb ($self->{ctx});Net::SSLeay::CTX_free ($self->{ctx})}sub init() {return if$REF_IDX;AE::log 5=>"Net::SSLeay versions older than 1.33 might malfunction." if$Net::SSLeay::VERSION < 1.33;Net::SSLeay::load_error_strings ();Net::SSLeay::SSLeay_add_ssl_algorithms ();Net::SSLeay::randomize ();$REF_IDX=Net::SSLeay::get_ex_new_index (0,0,0,0,0)until$REF_IDX}sub certname {$_[0]? Net::SSLeay::X509_NAME_oneline (Net::SSLeay::X509_get_issuer_name ($_[0])).Net::SSLeay::X509_NAME_oneline (Net::SSLeay::X509_get_subject_name ($_[0])): undef}our%CN_SCHEME=(rfc4513=>[0,1,2],rfc2818=>[0,2,1],rfc3207=>[0,0,2],none=>[],ldap=>"rfc4513",ldaps=>"ldap",http=>"rfc2818",https=>"http",smtp=>"rfc3207",smtps=>"smtp",xmpp=>"rfc3920",rfc3920=>"http",pop3=>"rfc2595",rfc2595=>"ldap",pop3s=>"pop3",imap=>"rfc2595",rfc2595=>"ldap",imaps=>"imap",acap=>"rfc2595",rfc2595=>"ldap",nntp=>"rfc4642",rfc4642=>"ldap",nntps=>"nntp",ftp=>"rfc4217",rfc4217=>"http",ftps=>"ftp",);sub match_cn($$$) {my ($name,$cn,$type)=@_;for ($name,$cn){s/[\x00-\x1f]+$//;s/^[\x00-\x1f]+//}my$pattern;if ($type==2 and $name =~m{^([^.]*)\*(.+)}){$pattern=qr{^\Q$1\E[^.]*\Q$2\E$}i}elsif ($type==1 and $name =~m{^\*(\..+)$}){$pattern=qr{^[^.]*\Q$1\E$}i}else {$pattern=qr{^\Q$name\E$}i}$cn =~ $pattern}sub verify_hostname($$$) {my ($cn,$cert,$scheme)=@_;while (!ref$scheme){$scheme=$CN_SCHEME{$scheme}or return 1}my$cert_cn=Net::SSLeay::X509_NAME_get_text_by_NID (Net::SSLeay::X509_get_subject_name ($cert),Net::SSLeay::NID_commonName ());my@cert_alt=Net::SSLeay::X509_get_subjectAltNames ($cert);require AnyEvent::Socket;my$ip=AnyEvent::Socket::parse_address ($cn);my$alt_dns_count;while (my ($type,$name)=splice@cert_alt,0,2){if ($type==Net::SSLeay::GEN_IPADD ()){return 1 if$ip eq $name}elsif ($type==Net::SSLeay::GEN_DNS ()){$alt_dns_count++;return 1 if match_cn$name,$cn,$scheme->[1]}}if ($scheme->[2]==2 || ($scheme->[2]==1 &&!$alt_dns_count)){return 1 if match_cn$cert_cn,$cn,$scheme->[0]}0}1
ANYEVENT_TLS

$fatpacked{"AnyEvent/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_UTIL';
  package AnyEvent::Util;use Carp ();use Errno ();use Socket ();use AnyEvent ();BEGIN {AnyEvent::common_sense}use base 'Exporter';our@EXPORT=qw(fh_nonblocking guard fork_call portable_pipe portable_socketpair run_cmd);our@EXPORT_OK=qw(AF_INET6 WSAEWOULDBLOCK WSAEINPROGRESS WSAEINVAL close_all_fds_except punycode_encode punycode_decode idn_nameprep idn_to_ascii idn_to_unicode);our$VERSION=$AnyEvent::VERSION;BEGIN {if ($AnyEvent::PROTOCOL{ipv6}&& _AF_INET6 && socket my$ipv6_socket,_AF_INET6,Socket::SOCK_DGRAM(),0){*AF_INET6=\&_AF_INET6}else {*AF_INET6=sub () {0};delete$AnyEvent::PROTOCOL{ipv6}}my%ERR=(EBADMSG=>Errno::EDOM (),EPROTO=>Errno::ESPIPE (),);while (my ($k,$v)=each%ERR){next if eval "Errno::$k ()";AE::log 8=>"Broken Errno module, adding Errno::$k.";eval "sub Errno::$k () { $v }";push@Errno::EXPORT_OK,$k;push @{$Errno::EXPORT_TAGS{POSIX}},$k}}BEGIN {if (AnyEvent::WIN32){*_win32_socketpair=sub () {for (1..10){socket my$l,Socket::AF_INET(),Socket::SOCK_STREAM(),0 or next;bind$l,Socket::pack_sockaddr_in 0,"\x7f\x00\x00\x01" or next;my$sa=getsockname$l or next;listen$l,1 or next;socket my$r,Socket::AF_INET(),Socket::SOCK_STREAM(),0 or next;bind$r,Socket::pack_sockaddr_in 0,"\x7f\x00\x00\x01" or next;connect$r,$sa or next;accept my$w,$l or next;(Socket::unpack_sockaddr_in getpeername$r)[0]==(Socket::unpack_sockaddr_in getsockname$w)[0]or (($!=WSAEINVAL),next);return ($r,$w)}()};*portable_socketpair=\&_win32_socketpair;*portable_pipe=\&_win32_socketpair}else {*portable_pipe=sub () {my ($r,$w);pipe$r,$w or return;($r,$w)};*portable_socketpair=sub () {socketpair my$fh1,my$fh2,Socket::AF_UNIX(),Socket::SOCK_STREAM(),0 or return;($fh1,$fh2)}}}our$MAX_FORKS=int 1 * $ENV{PERL_ANYEVENT_MAX_FORKS};$MAX_FORKS=10 if$MAX_FORKS <= 0;my$forks;my@fork_queue;sub _fork_schedule;sub _fork_schedule {require Storable unless$Storable::VERSION;require POSIX unless$POSIX::VERSION;while ($forks < $MAX_FORKS){my$job=shift@fork_queue or last;++$forks;my$coderef=shift @$job;my$cb=pop @$job;my ($r,$w)=portable_pipe or ($forks and last)or die "fork_call: $!";my$pid=fork;if ($pid!=0){close$w;my$buf;my$ww;$ww=AE::io$r,0,sub {my$len=sysread$r,$buf,65536,length$buf;return unless defined$len or $!!=Errno::EINTR;if (!$len){undef$ww;close$r;--$forks;_fork_schedule;my$result=eval {Storable::thaw ($buf)};$result=[$@]unless$result;$@=shift @$result;$cb->(@$result);kill 9,$pid if AnyEvent::WIN32;waitpid$pid,0}}}elsif (defined$pid){close$r;my$result=eval {local$SIG{__DIE__};Storable::freeze ([undef,$coderef->(@$job)])};$result=Storable::freeze (["$@"])if $@;my$ofs;while (){my$len=(length$result)- $ofs or last;$len=syswrite$w,$result,$len < 65536 ? $len : 65536,$ofs;last unless$len || (!defined$len && $!==Errno::EINTR);$ofs += $len}if (AnyEvent::WIN32){shutdown$w,1;sleep 10;sysread$w,(my$buf),1}POSIX::_exit (0);exit 1}elsif (($!!=&Errno::EAGAIN && $!!=&Errno::EWOULDBLOCK && $!!=&Errno::ENOMEM)||!$forks){die "fork_call: $!"}}}sub fork_call(&@) {push@fork_queue,[@_];_fork_schedule}END {if (AnyEvent::WIN32){while ($forks){@fork_queue=();AnyEvent->one_event}}}sub dotted_quad($) {$_[0]=~ /^(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[0-9][0-9]?)
              \.(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[0-9][0-9]?)
              \.(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[0-9][0-9]?)
              \.(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[0-9][0-9]?)$/x}sub inet_aton {require AnyEvent::Socket;*inet_aton=\&AnyEvent::Socket::inet_aton;goto&inet_aton}BEGIN {*fh_nonblocking=\&AnyEvent::_fh_nonblocking}BEGIN {if (!$ENV{PERL_ANYEVENT_AVOID_GUARD}&& eval {require Guard;$Guard::VERSION >= 0.5}){*guard=\&Guard::guard;AE::log 8=>"Using Guard module to implement guards."}else {*AnyEvent::Util::guard::DESTROY=sub {local $@;eval {local$SIG{__DIE__};${$_[0]}->()};AE::log 4=>"Runtime error in AnyEvent::guard callback: $@" if $@};*AnyEvent::Util::guard::cancel=sub ($) {${$_[0]}=sub {}};*guard=sub (&) {bless \(my$cb=shift),"AnyEvent::Util::guard"};AE::log 8=>"Using pure-perl guard implementation."}}sub close_all_fds_except {my%except;@except{@_}=();require POSIX unless$POSIX::VERSION;if ($^O =~ /(freebsd|cygwin|linux)/){my$dir;if (opendir$dir,"/dev/fd" or opendir$dir,"/proc/self/fd"){my@fds=sort {$a <=> $b}grep /^\d+$/,readdir$dir;if (@fds < 20 or "@fds" ne join " ",0..$#fds){exists$except{$_}or POSIX::close ($_)for@fds;return}}}my$fd_max=eval {POSIX::sysconf (POSIX::_SC_OPEN_MAX ())- 1}|| 1023;exists$except{$_}or POSIX::close ($_)for 0..$fd_max}sub run_cmd {my$cmd=shift;require POSIX unless$POSIX::VERSION;my$cv=AE::cv;my%arg;my%redir;my@exe;while (@_){my ($type,$ob)=splice @_,0,2;my$fd=$type =~ s/^(\d+)// ? $1 : undef;if ($type eq ">"){$fd=1 unless defined$fd;if (defined eval {fileno$ob}){$redir{$fd}=$ob}elsif (ref$ob){my ($pr,$pw)=AnyEvent::Util::portable_pipe;$cv->begin;fcntl$pr,AnyEvent::F_SETFD,AnyEvent::FD_CLOEXEC;fh_nonblocking$pr,1;my$w;$w=AE::io$pr,0,"SCALAR" eq ref$ob ? sub {defined (sysread$pr,$$ob,16384,length $$ob and return)or ($!==Errno::EINTR and return);undef$w;$cv->end}: sub {my$buf;defined (sysread$pr,$buf,16384 and return$ob->($buf))or ($!==Errno::EINTR and return);undef$w;$cv->end;$ob->()};$redir{$fd}=$pw}else {push@exe,sub {open my$fh,">",$ob or POSIX::_exit (125);$redir{$fd}=$fh}}}elsif ($type eq "<"){$fd=0 unless defined$fd;if (defined eval {fileno$ob}){$redir{$fd}=$ob}elsif (ref$ob){my ($pr,$pw)=AnyEvent::Util::portable_pipe;$cv->begin;my$data;if ("SCALAR" eq ref$ob){$data=$$ob;$ob=sub {}}else {$data=$ob->()}fcntl$pw,AnyEvent::F_SETFD,AnyEvent::FD_CLOEXEC;fh_nonblocking$pw,1;my$w;$w=AE::io$pw,1,sub {my$len=syswrite$pw,$data;return unless defined$len or $!!=Errno::EINTR;if (!$len){undef$w;$cv->end}else {substr$data,0,$len,"";unless (length$data){$data=$ob->();unless (length$data){undef$w;$cv->end}}}};$redir{$fd}=$pr}else {push@exe,sub {open my$fh,"<",$ob or POSIX::_exit (125);$redir{$fd}=$fh}}}else {$arg{$type}=$ob}}my$pid=fork;defined$pid or Carp::croak "fork: $!";unless ($pid){$_->()for@exe;my (@oldfh,@close);for my$fh (values%redir){push@oldfh,$fh;$fh=fileno$fh;defined ($fh=POSIX::dup ($fh))or POSIX::_exit (124)while exists$redir{$fh}}while (my ($k,$v)=each%redir){defined POSIX::dup2 ($v,$k)or POSIX::_exit (123)}if ($arg{close_all}){close_all_fds_except 0,1,2,keys%redir}else {POSIX::close ($_)for values%redir}eval {$arg{on_prepare}();1}or POSIX::_exit (123)if exists$arg{on_prepare};ref$cmd ? exec {$cmd->[0]}@$cmd : exec$cmd;POSIX::_exit (126)}${$arg{'$$'}}=$pid if$arg{'$$'};%redir=();my$status;$cv->begin (sub {shift->send ($status)});my$cw;$cw=AE::child$pid,sub {$status=$_[1];undef$cw;$cv->end};$cv}sub punycode_encode($) {require "AnyEvent/Util/idna.pl";goto&punycode_encode}sub punycode_decode($) {require "AnyEvent/Util/idna.pl";goto&punycode_decode}our ($uts46_valid,$uts46_imap);sub idn_nameprep($;$) {local $_=$_[0];y/A-Z/a-z/;if (/[^0-9a-z\-.]/){unless (defined$uts46_imap){require Unicode::Normalize;require "AnyEvent/Util/uts46data.pl"}s{
           ([^0-9a-z\-.])
        }{
           my $chr = $1;
           unless (vec $uts46_valid, ord $chr, 1) {
              # not in valid class, search for mapping
              utf8::encode $chr; # the imap table is in utf-8
              (my $rep = index $uts46_imap, "\x00$chr") >= 0
                 or Carp::croak "$_[0]: disallowed characters ($chr) during idn_nameprep" . unpack "H*", $chr;
  
              (substr $uts46_imap, $rep, 128) =~ /\x00 .[\x80-\xbf]* ([^\x00]*) \x00/x
                 or die "FATAL: idn_nameprep imap table has unexpected contents";
  
              $rep = $1;
              $chr = $rep unless $rep =~ s/^\x01// && $_[1]; # replace unless deviation and display
              utf8::decode $chr;
           }
           $chr
        }gex;$_=Unicode::Normalize::NFKC ($_)}s{
        (^|\.)(..)--([^\.]*)
     }{
        my ($pfx, $ace, $pc) = ($1, $2, $3);
  
        if ($ace eq "xn") {
           $pc = punycode_decode $pc; # will croak on error (we hope :)
  
           require Unicode::Normalize;
           $pc eq Unicode::Normalize::NFC ($pc)
              or Carp::croak "$_[0]: punycode label not in NFC detected during idn_nameprep";
  
           "$pfx$pc"
        } elsif ($ace !~ /^[a-z0-9]{2}$/) {
           "$pfx$ace--$pc"
        } else {
           Carp::croak "$_[0]: hyphens in 3rd/4th position of a label are not allowed";
        }
     }gex;/\.-|-\./ and Carp::croak "$_[0]: invalid hyphens detected during idn_nameprep";if (/[^0-9a-z\-.]/){unless (defined$uts46_imap){require "AnyEvent/Util/uts46data.pl"}vec$uts46_valid,ord,1 or $_[1]&& 0 <= index$uts46_imap,pack "C0U*",0,ord,1 or Carp::croak "$_[0]: disallowed characters during idn_nameprep" for split //}$_}sub idn_to_ascii($) {return $_[0]unless $_[0]=~ /[^\x00-\x7f]/;my@output;eval {for (split /\./,(idn_nameprep $_[0]),-1){if (/[^\x00-\x7f]/){eval {push@output,"xn--" .punycode_encode $_;1}or do {push@output,$_}}else {push@output,$_}}1}or return $_[0];shift@output while!length$output[0]&& @output > 1;join ".",@output}sub idn_to_unicode($) {my$res=eval {idn_nameprep $_[0],1};defined$res ? $res : $_[0]}1
ANYEVENT_UTIL

$fatpacked{"AnyEvent/Util/idna.pl"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_UTIL_IDNA.PL';
  use AnyEvent ();BEGIN {AnyEvent::common_sense}use Carp ();use List::Util ();use integer;sub pyc_base () {36}sub pyc_tmin () {1}sub pyc_tmax () {26}sub pyc_initial_bias () {72}sub pyc_initial_n () {128}sub pyc_digits () {"abcdefghijklmnopqrstuvwxyz0123456789"}sub pyc_adapt($$$) {my ($delta,$numpoints,$firsttime)=@_;$delta=$firsttime ? $delta / 700 : $delta >> 1;$delta += $delta / $numpoints;my$k;while ($delta > (pyc_base - pyc_tmin)* pyc_tmax / 2){$delta /= pyc_base - pyc_tmin;$k += pyc_base}$k + $delta * (pyc_base - pyc_tmin + 1)/ ($delta + 38)}sub punycode_encode($) {my ($input)=@_;my ($n,$bias,$delta)=(pyc_initial_n,pyc_initial_bias);(my$output=$input)=~ y/\x00-\x7f//cd;my$h=my$b=length$output;my@input=split '',$input;$output .= "-" if$b && $h < @input;while ($h < @input){my$m=List::Util::min grep {$_ >= $n}map ord,@input;$m - $n <= (0x7fffffff - $delta)/ ($h + 1)or Carp::croak "punycode_encode: overflow in punycode delta encoding";$delta += ($m - $n)* ($h + 1);$n=$m;for my$i (@input){my$c=ord$i;++$delta < 0x7fffffff or Carp::croak "punycode_encode: overflow in punycode delta encoding" if$c < $n;if ($c==$n){my ($q,$k)=($delta,pyc_base);while (){my$t=List::Util::min pyc_tmax,List::Util::max pyc_tmin,$k - $bias;last if$q < $t;$output .= substr pyc_digits,$t + (($q - $t)% (pyc_base - $t)),1;$q=($q - $t)/ (pyc_base - $t);$k += pyc_base}$output .= substr pyc_digits,$q,1;$bias=pyc_adapt$delta,$h + 1,$h==$b;$delta=0;++$h}}++$delta;++$n}$output}sub punycode_decode($) {my ($input)=@_;my ($n,$bias,$i)=(pyc_initial_n,pyc_initial_bias);my$output;if ($input =~ /^(.*?)-([^-]*)$/x){$output=$1;$input=$2;$output =~ /[^\x00-\x7f]/ and Carp::croak "punycode_decode: malformed punycode"}while (length$input){my$oldi=$i;my$w=1;for (my$k=pyc_base;;$k += pyc_base){(my$digit=index pyc_digits,substr$input,0,1,"")>= 0 or Carp::croak "punycode_decode: malformed punycode";$i += $digit * $w;my$t=List::Util::max pyc_tmin,List::Util::min pyc_tmax,$k - $bias;last if$digit < $t;$w *= pyc_base - $t}my$outlen=1 + length$output;$bias=pyc_adapt$i - $oldi,$outlen,$oldi==0;$n += $i / $outlen;$i %= $outlen;substr$output,$i,0,chr$n;++$i}$output}1
ANYEVENT_UTIL_IDNA.PL

$fatpacked{"AnyEvent/Util/uts46data.pl"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_UTIL_UTS46DATA.PL';
  $uts46_imap=q Aa Bb Cc Dd Ee Ff Gg Hh Ii Jj Kk Ll Mm Nn Oo Pp Qq Rr Ss Tt Uu Vv Ww Xx Yy Zz a  2 3  1 o 14 12 34                               ss                         i ij ij      l l     n                            s                                     d d d lj lj lj nj nj nj                  dz dz dz                                               h  j r    w y  l s x                                                                                                                                                                                                                                                                                                                         a  b d e  g h i j k l m n o  p r t u w a    b d e    g k m  o    p t u   v       i r u v        c    f                           z                                                                                a  ss                                                                                                                                                                                                          0 i 4 5 6 7 8 9  n 0 1 2 3 4 5 6 7 8 9  a e o x  h k l m n p s t rs c c  f g h h h h  i i l l n no p q r r r sm tel tm z  z k  b c e e f m o     i fax      d d e i j 17 19 110 13 23 15 25 35 45 16 56 18 38 58 78 1 i ii iii iv v vi vii viii ix x xi xii l c d m i ii iii iv v vi vii viii ix x xi xii l c d m 03       1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z 0                                                               j v                                                                                                                                                                                                                                                                                 .                                                                                                                      pte 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35                                                                                 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 1 2 3 4 5 6 7 8 9 10 11 12 hg erg ev ltd                                                                                                                                        0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 hpa da au bar ov pc dm dm2 dm3 iu      pa na a ma ka kb mb gb cal kcal pf nf f g mg kg hz khz mhz ghz thz l ml dl kl fm nm m mm cm km mm2 cm2 m2 km2 mm3 cm3 m3 km3 ms ms2 pa kpa mpa gpa rad rads rads2 ps ns s ms pv nv v mv kv mv pw nw w mw kw mw k m bq cc cd ckg db gy ha hp in kk km kt lm ln log lx mb mil mol ph ppm pr sr sv wb vm am 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 gal                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           ff fi fl ffi ffl st st                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               -                                                                                                                                     - . 0 1 2 3 4 5 6 7 8 9 a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z   .                                                                                                                                                                                    a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z a c d g j k n o p q s t u v w x y z a b c d f h i j k l m n p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z a b d e f g j k l m n o p q s t u v w x y a b c d e f g h i j k l m n o p q r s t u v w x y z a b d e f g i j k l m o s t u v w x y a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f g h i j k l m n o p q r s t u v w x y z                                                                                                                                                                                                                                                                                                       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9                                                                                                                                              s c r cd wz a b c d e f g h i j k l m n o p q r s t u v w x y z hv mv sd ss ppv wc mc md dj                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ;$uts46_valid=q     `        Z   UTT)1$N*-Q@U! 8    H      T        ? ?O               y %9? ;  9 == =` =`@ } ?/_       %;_?    {{          ======     
   ? ? ? ?                      @          ?   ?   U      C @   @   } '           B       O?                                                 b           {                                 f?                                                                            ?           W
                  ?   ~~~                   ?                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               @                                                                                               `                                                      ??          ?                            ?          ?                                                                                                          ?                                    o                 ??                                                                                                                                  ?                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ? ??    ?                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ?                         ?                                                                                                                                                                                                                                                                                              ?;1;
ANYEVENT_UTIL_UTS46DATA.PL

$fatpacked{"AnyEvent/constants.pl"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ANYEVENT_CONSTANTS.PL';
  sub AnyEvent::common_sense {local $^W;${^WARNING_BITS} ^= ${^WARNING_BITS} ^ "\x3c\x3f\x33\x00\x0f\xf0\x0f\xc0\xf0\xfc\x33\x00\x00\x00\xc0\x00";$^H |= 0x7c0}package AnyEvent;sub CYGWIN(){0}sub WIN32(){0}sub F_SETFD(){2}sub F_SETFL(){4}sub O_NONBLOCK(){4}sub FD_CLOEXEC(){1}package AnyEvent::Base;sub WNOHANG(){1}package AnyEvent::IO;sub O_RDONLY(){0}sub O_WRONLY(){1}sub O_RDWR(){2}sub O_CREAT(){512}sub O_EXCL(){2048}sub O_TRUNC(){1024}sub O_APPEND(){8}package AnyEvent::Util;sub WSAEINVAL(){-1e+99}sub WSAEWOULDBLOCK(){-1e+99}sub WSAEINPROGRESS(){-1e+99}sub _AF_INET6(){30}package AnyEvent::Socket;sub TCP_CONGESTION(){undef}sub TCP_CONNECTIONTIMEOUT(){32}sub TCP_CORK(){undef}sub TCP_DEFER_ACCEPT(){undef}sub TCP_INFO(){undef}sub TCP_INIT_CWND(){undef}sub TCP_KEEPALIVE(){16}sub TCP_KEEPCNT(){undef}sub TCP_KEEPIDLE(){undef}sub TCP_KEEPINIT(){undef}sub TCP_KEEPINTVL(){undef}sub TCP_LINGER2(){undef}sub TCP_MAXSEG(){2}sub TCP_MD5SIG(){undef}sub TCP_NOOPT(){8}sub TCP_NOPUSH(){4}sub TCP_QUICKACK(){undef}sub TCP_SACK_ENABLE(){undef}sub TCP_SYNCNT(){undef}sub TCP_WINDOW_CLAMP(){undef}1;
ANYEVENT_CONSTANTS.PL

$fatpacked{"App/irccat.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_IRCCAT';
  package App::irccat;use 5.008001;use strict;use warnings;use Carp ();use Getopt::Long ();use AnyEvent;use AnyEvent::Handle;use AnyEvent::IRC::Client;our$VERSION="0.01";sub new {my ($class,%args)=@_;return bless {host=>undef,port=>6667,nick=>$class->random_nick(),%args,},$class}sub run {my ($self,@args)=@_;my$p=Getopt::Long::Parser->new(config=>[qw/no_ignore_case pass_through/],);$p->getoptionsfromarray(\@args,'host=s'=>\$self->{host},'port=s'=>\$self->{port},'nick=s'=>\$self->{nick},'user=s'=>\$self->{user},'password=s'=>\$self->{password},'channel=s'=>\$self->{channel},'v|verbose'=>\$self->{verbose},'h|help'=>\$self->{help},);if ($self->{help}){return$self->help()}for my$key (qw/host channel/){unless (defined$self->{$key}){Carp::croak("Missing $key parameter")}}if (length$self->{nick}> 9){Carp::croak("Maximum nickname length is 9")}unless ($self->{channel}=~ /^#/){$self->{channel}='#' .$self->{channel}}$self->handle();return 0}sub handle {my$self=shift;my$cv=AE::cv;my$hdl;$hdl=AnyEvent::Handle->new(fh=>\*STDIN,on_error=>sub {my ($hdl,$fatal,$msg)=@_;AE::log(error=>$msg);$hdl->destroy;$cv->send},);my$con=AnyEvent::IRC::Client->new();$con->reg_cb(connect=>sub {my ($con,$err)=@_;if ($err){warn "Connection error: $err\n";$cv->send}else {if ($self->{verbose}){warn "Joining $self->{channel} channel...\n"}$con->send_srv(JOIN=>$self->{channel})}});$con->reg_cb(join=>sub {my ($con,$nick,$channel,$is_myself)=@_;if ($is_myself){if ($self->{verbose}){warn "Joined.\n"}$hdl->on_read(sub {my ($hdl)=@_;$hdl->push_read(line=>sub {my ($hdl,$line)=@_;$con->send_chan($self->{channel},'NOTICE',$self->{channel},$line)})})}});if ($self->{verbose}){warn "Connecting $self->{host}:$self->{port} (nick: $self->{nick})\n"}$con->connect($self->{host},$self->{port},{nick=>$self->{nick},(exists$self->{user}? (user=>$self->{user}): ()),(exists$self->{password}? (password=>$self->{password}): ()),});$cv->recv}sub help {print <<'...';return 1}sub random_nick {my$class=shift;my@chars=('0'..'9','a'..'z');my$random='';for my$i (1..2){$random .= $chars[int rand@chars]}return 'irccat_' .$random}1;
  Usage: irccat --channel=#channel --host=127.0.0.1 [--port=6667] [--nick=irccat] [--user=user] [--password=password]
  
  Example:
      % irccat --channel=#test --host=127.0.0.1 <<< 'hello~'
  
      % tail -f /var/log/messages | irccat --channel=#test --host=127.0.0.1
  ...
APP_IRCCAT

$fatpacked{"Canary/Stability.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CANARY_STABILITY';
  package Canary::Stability;BEGIN {$VERSION=2006}sub sgr {$ENV{PERL_CANARY_STABILITY_COLOUR}ne 0 and ((-t STDOUT and length$ENV{TERM})or $ENV{PERL_CANARY_STABILITY_COLOUR})and print "\e[$_[0]m"}sub import {my (undef,$distname,$minvers,$minperl)=@_;$ENV{PERL_CANARY_STABILITY_DISABLE}and return;$minperl ||= 5.008002;if ($minvers > $VERSION){sgr 33;print <<EOF}elsif ($] < $minperl){sgr 33;print <<EOF}elsif (defined$Internals::StabilityBranchVersion){sgr 32;print <<EOF}elsif ($] < 5.021){print <<EOF}else {sgr 31;print <<EOF;sgr 0;print <<EOF;unless ($ENV{PERL_CANARY_STABILITY_NOPROMPT}){require ExtUtils::MakeMaker;ExtUtils::MakeMaker::prompt ("Continue anyways? ","y")=~ /^y/i or die "FATAL: User aborted configuration of $distname.\n"}}sgr 0}1
  
  ***
  *** The stability canary says: (nothing, it died of old age).
  ***
  *** Your Canary::Stability module (used by $distname) is too old.
  *** This is not a fatal problem - while you might want to upgrade to version
  *** $minvers (currently installed version: $VERSION) to get better support
  *** status testing, you might also not want to care at all, and all will
  *** be well as long $distname works well enough for you, as the stability
  *** canary is only used when installing the distribution.
  ***
  
  EOF
  
  ***
  *** The stability canary says: chirp (it seems concerned about something).
  ***
  *** Your perl version ($]) is older than the $distname distribution
  *** likes ($minperl). This is not a fatal problem - the module might work
  *** well with your version of perl, but it does mean the author likely
  *** won't do anything to make it work if it breaks.
  ***
  
  EOF
  
  ***
  *** The stability canary says: chirp! chirp! (it seems to be quite excited)
  ***
  *** It seems you are running schmorp's stability branch of perl.
  *** All should be well, and if it isn't, you should report this as a bug
  *** to the $distname author.
  ***
  
  EOF
  
  ***
  *** The stability canary says: chirp! chirp! (it seems to be quite happy)
  ***
  *** Your version of perl ($]) is quite supported by $distname, nothing
  *** else to be said, hope it comes in handy.
  ***
  
  EOF
  
  ***
  *** The stability canary says: (nothing, it was driven away by harsh weather)
  ***
  *** It seems you are running perl version $], likely the "official" or
  *** "standard" version. While there is nothing wrong with doing that,
  *** standard perl versions 5.022 and up are not supported by $distname.
  *** While this might be fatal, it might also be all right - if you run into
  *** problems, you might want to downgrade your perl or switch to the
  *** stability branch.
  ***
  *** If everything works fine, you can ignore this message.
  ***
  EOF
  *** Stability canary mini-FAQ:
  ***
  *** Do I need to do anything?
  ***    With luck, no. While some distributions are known to fail
  ***    already, most should probably work. This message is here
  ***    to alert you that your perl is not supported by $distname,
  ***    and if things go wrong, you either need to downgrade, or
  ***    sidegrade to the stability variant of your perl version,
  ***    or simply live with the consequences.
  ***
  *** What is this canary thing?
  ***    It's purpose is to check support status of $distname with
  ***    respect to your perl version.
  ***
  *** What is this "stability branch"?
  ***    It's a branch or fork of the official perl, by schmorp, to
  ***    improve stability and compatibility with existing modules.
  ***
  *** How can I skip this prompt on automated installs?
  ***    Set PERL_CANARY_STABILITY_NOPROMPT=1 in your environment.
  ***    More info is in the Canary::Stability manpage.
  ***
  *** Long version of this FAQ: http://stableperl.schmorp.de/faq.html
  *** Stability Branch homepage: http://stableperl.schmorp.de/
  ***
  
  EOF
CANARY_STABILITY

$fatpacked{"ExtUtils/Config.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_CONFIG';
  package ExtUtils::Config;$ExtUtils::Config::VERSION='0.008';use strict;use warnings;use Config;use Data::Dumper ();sub new {my ($pack,$args)=@_;return bless {values=>($args ? {%$args }: {}),},$pack}sub get {my ($self,$key)=@_;return exists$self->{values}{$key}? $self->{values}{$key}: $Config{$key}}sub exists {my ($self,$key)=@_;return exists$self->{values}{$key}|| exists$Config{$key}}sub values_set {my$self=shift;return {%{$self->{values}}}}sub all_config {my$self=shift;return {%Config,%{$self->{values}}}}sub serialize {my$self=shift;return$self->{serialized}||= Data::Dumper->new([$self->values_set])->Terse(1)->Sortkeys(1)->Dump}1;
EXTUTILS_CONFIG

$fatpacked{"ExtUtils/Helpers.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_HELPERS';
  package ExtUtils::Helpers;$ExtUtils::Helpers::VERSION='0.022';use strict;use warnings FATAL=>'all';use Exporter 5.57 'import';use Config;use File::Basename qw/basename/;use File::Spec::Functions qw/splitpath canonpath abs2rel splitdir/;use Module::Load;our@EXPORT_OK=qw/make_executable split_like_shell man1_pagename man3_pagename detildefy/;BEGIN {my%impl_for=(MSWin32=>'Windows',VMS=>'VMS');my$package='ExtUtils::Helpers::' .($impl_for{$^O}|| 'Unix');load($package);$package->import()}sub man1_pagename {my$filename=shift;return basename($filename).".$Config{man1ext}"}my%separator=(MSWin32=>'.',VMS=>'__',os2=>'.',cygwin=>'.',);my$separator=$separator{$^O}|| '::';sub man3_pagename {my ($filename,$base)=@_;$base ||= 'lib';my ($vols,$dirs,$file)=splitpath(canonpath(abs2rel($filename,$base)));$file=basename($file,qw/.pm .pod/);my@dirs=grep {length}splitdir($dirs);return join$separator,@dirs,"$file.$Config{man3ext}"}1;
EXTUTILS_HELPERS

$fatpacked{"ExtUtils/Helpers/Unix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_HELPERS_UNIX';
  package ExtUtils::Helpers::Unix;$ExtUtils::Helpers::Unix::VERSION='0.022';use strict;use warnings FATAL=>'all';use Exporter 5.57 'import';our@EXPORT=qw/make_executable split_like_shell detildefy/;use Carp qw/croak/;use Config;use Text::ParseWords 3.24 qw/shellwords/;my$layer=$] >= 5.008001 ? ":raw" : "";sub make_executable {my$filename=shift;my$current_mode=(stat$filename)[2]+ 0;if (-T $filename){open my$fh,"<$layer",$filename;my@lines=<$fh>;if (@lines and $lines[0]=~ s{ \A \#! \s* (?:/\S+/)? perl \b (.*) \z }{$Config{startperl}$1}xms){open my$out,">$layer","$filename.new" or croak "Couldn't open $filename.new: $!";print$out @lines;close$out;rename$filename,"$filename.bak" or croak "Couldn't rename $filename to $filename.bak";rename "$filename.new",$filename or croak "Couldn't rename $filename.new to $filename";unlink "$filename.bak"}}chmod$current_mode | oct(111),$filename;return}sub split_like_shell {my ($string)=@_;return if not defined$string;$string =~ s/^\s+|\s+$//g;return if not length$string;return shellwords($string)}sub detildefy {my$value=shift;for ($value){s{ ^ ~ (?= /|$)}          [ $ENV{HOME} || (getpwuid $>)[7] ]ex or s{ ^ ~ ([^/]+) (?= /|$) } { (getpwnam $1)[7] || "~$1" }ex}return$value}1;
EXTUTILS_HELPERS_UNIX

$fatpacked{"ExtUtils/Helpers/VMS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_HELPERS_VMS';
  package ExtUtils::Helpers::VMS;$ExtUtils::Helpers::VMS::VERSION='0.022';use strict;use warnings FATAL=>'all';use Exporter 5.57 'import';our@EXPORT=qw/make_executable split_like_shell detildefy/;use ExtUtils::Helpers::Unix qw/split_like_shell/;use File::Copy qw/copy/;sub make_executable {my$filename=shift;my$batchname="$filename.com";copy($filename,$batchname);ExtUtils::Helpers::Unix::make_executable($batchname);return}sub detildefy {my$arg=shift;return$arg if ($arg =~ /^~~/);return$arg if ($arg =~ /^~ /);if ($arg =~ /^~/){my$spec=$arg;$spec =~ s/^~//;$spec =~ s#^/##;my$home=VMS::Filespec::unixify($ENV{HOME});$home .= '/' unless$home =~ m#/$#;if ($spec eq ''){$home =~ s#/$##;return$home}my ($hvol,$hdir,$hfile)=File::Spec::Unix->splitpath($home);if ($hdir eq ''){$hdir=$hfile}my ($vol,$dir,$file)=File::Spec::Unix->splitpath($spec);my@hdirs=File::Spec::Unix->splitdir($hdir);my@dirs=File::Spec::Unix->splitdir($dir);my$newdirs;if ($arg =~ m#^~/#){$newdirs=File::Spec::Unix->catdir(@hdirs,@dirs)}else {my@backup=File::Spec::Unix->splitdir(File::Spec::Unix->updir);$newdirs=File::Spec::Unix->catdir(@hdirs,@backup,@dirs)}$arg=File::Spec::Unix->catpath($hvol,$newdirs,$file)}return$arg}
EXTUTILS_HELPERS_VMS

$fatpacked{"ExtUtils/Helpers/Windows.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_HELPERS_WINDOWS';
  package ExtUtils::Helpers::Windows;$ExtUtils::Helpers::Windows::VERSION='0.022';use strict;use warnings FATAL=>'all';use Exporter 5.57 'import';our@EXPORT=qw/make_executable split_like_shell detildefy/;use Config;use Carp qw/carp croak/;sub make_executable {my$script=shift;if (-T $script && $script !~ / \. (?:bat|cmd) $ /x){_pl2bat(in=>$script,update=>1)}return}sub _pl2bat {my%opts=@_;$opts{ntargs}='-x -S %0 %*';$opts{otherargs}='-x -S "%0" %1 %2 %3 %4 %5 %6 %7 %8 %9';$opts{stripsuffix}=qr/\.plx?/ unless exists$opts{stripsuffix};if (not exists$opts{out}){$opts{out}=$opts{in};$opts{out}=~ s/$opts{stripsuffix}$//i;$opts{out}.= '.bat' unless$opts{in}=~ /\.bat$/i or $opts{in}eq '-'}my$head=<<"EOT";$head =~ s/^\s+//gm;my$headlines=2 + ($head =~ tr/\n/\n/);my$tail=<<'EOT';$tail =~ s/^\s+//gm;my$linedone=0;my$taildone=0;my$linenum=0;my$skiplines=0;my$start=$Config{startperl};$start='#!perl' unless$start =~ /^#!.*perl/;open my$in,'<',$opts{in}or croak "Can't open $opts{in}: $!";my@file=<$in>;close$in;for my$line (@file){$linenum++;if ($line =~ /^:endofperl\b/){if (!exists$opts{update}){warn "$opts{in} has already been converted to a batch file!\n";return}$taildone++}if (not $linedone and $line =~ /^#!.*perl/){if (exists$opts{update}){$skiplines=$linenum - 1;$line .= '#line '.(1+$headlines)."\n"}else {$line .= '#line '.($linenum+$headlines)."\n"}$linedone++}if ($line =~ /^#\s*line\b/ and $linenum==2 + $skiplines){$line=''}}open my$out,'>',$opts{out}or croak "Can't open $opts{out}: $!";print$out $head;print$out $start,($opts{usewarnings}? ' -w' : ''),"\n#line ",($headlines+1),"\n" unless$linedone;print$out @file[$skiplines..$#file];print$out $tail unless$taildone;close$out;return$opts{out}}sub split_like_shell {local ($_)=@_;my@argv;return@argv unless defined && length;my$arg='';my ($i,$quote_mode)=(0,0);while ($i < length){my$ch=substr $_,$i,1;my$next_ch=substr $_,$i+1,1;if ($ch eq '\\' && $next_ch eq '"'){$arg .= '"';$i++}elsif ($ch eq '\\' && $next_ch eq '\\'){$arg .= '\\';$i++}elsif ($ch eq '"' && $next_ch eq '"' && $quote_mode){$quote_mode=!$quote_mode;$arg .= '"';$i++}elsif ($ch eq '"' && $next_ch eq '"' &&!$quote_mode && ($i + 2==length()|| substr($_,$i + 2,1)eq ' ')){push@argv,$arg;$arg='';$i += 2}elsif ($ch eq '"'){$quote_mode=!$quote_mode}elsif ($ch =~ /\s/ &&!$quote_mode){push@argv,$arg if$arg;$arg='';++$i while substr($_,$i + 1,1)=~ /\s/}else {$arg .= $ch}$i++}push@argv,$arg if defined$arg && length$arg;return@argv}sub detildefy {my$value=shift;$value =~ s{ ^ ~ (?= [/\\] | $ ) }[$ENV{USERPROFILE}]x if$ENV{USERPROFILE};return$value}1;
  	\@rem = '--*-Perl-*--
  	\@echo off
  	if "%OS%" == "Windows_NT" goto WinNT
  	perl $opts{otherargs}
  	\@set ErrorLevel=%ErrorLevel%
  	goto endofperl
  	:WinNT
  	perl $opts{ntargs}
  	\@set ErrorLevel=%ErrorLevel%
  	if NOT "%COMSPEC%" == "%SystemRoot%\\system32\\cmd.exe" goto endofperl
  	if %errorlevel% == 9009 echo You do not have Perl in your PATH.
  	goto endofperl
  	\@rem ';
  EOT
  	__END__
  	:endofperl
  	@"%COMSPEC%" /c exit /b %ErrorLevel%
  EOT
EXTUTILS_HELPERS_WINDOWS

$fatpacked{"ExtUtils/InstallPaths.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_INSTALLPATHS';
  package ExtUtils::InstallPaths;$ExtUtils::InstallPaths::VERSION='0.011';use 5.006;use strict;use warnings;use File::Spec ();use Carp ();use ExtUtils::Config 0.002;my%complex_accessors=map {$_=>1}qw/prefix_relpaths install_sets/;my%hash_accessors=map {$_=>1}qw/install_path install_base_relpaths original_prefix/;my%defaults=(installdirs=>'site',install_base=>undef,prefix=>undef,verbose=>0,blib=>'blib',create_packlist=>1,dist_name=>undef,module_name=>undef,destdir=>undef,install_path=>sub {{}},install_sets=>\&_default_install_sets,original_prefix=>\&_default_original_prefix,install_base_relpaths=>\&_default_base_relpaths,prefix_relpaths=>\&_default_prefix_relpaths,);sub _merge_shallow {my ($name,$filter)=@_;return sub {my ($override,$config)=@_;my$defaults=$defaults{$name}->($config);$filter->($_)for grep$filter,values %$override;return {%$defaults,%$override }}}sub _merge_deep {my ($name,$filter)=@_;return sub {my ($override,$config)=@_;my$defaults=$defaults{$name}->($config);my$pair_for=sub {my$key=shift;my%override=%{$override->{$key}|| {}};$filter && $filter->($_)for values%override;return$key=>{%{$defaults->{$key}},%override }};return {map {$pair_for->($_)}keys %$defaults }}}my%allowed_installdir=map {$_=>1}qw/core site vendor/;my$must_be_relative=sub {Carp::croak('Value must be a relative path')if File::Spec->file_name_is_absolute($_[0])};my%deep_filter=map {$_=>$must_be_relative}qw/install_base_relpaths prefix_relpaths/;my%filter=(installdirs=>sub {my$value=shift;$value='core',Carp::carp('Perhaps you meant installdirs to be "core" rather than "perl"?')if$value eq 'perl';Carp::croak('installdirs must be one of "core", "site", or "vendor"')if not $allowed_installdir{$value};return$value},(map {$_=>_merge_shallow($_,$deep_filter{$_})}qw/original_prefix install_base_relpaths/),(map {$_=>_merge_deep($_,$deep_filter{$_})}qw/install_sets prefix_relpaths/),);sub new {my ($class,%args)=@_;my$config=$args{config}|| ExtUtils::Config->new;my%self=(config=>$config,map {$_=>exists$args{$_}? $filter{$_}? $filter{$_}->($args{$_},$config): $args{$_}: ref$defaults{$_}? $defaults{$_}->($config): $defaults{$_}}keys%defaults,);$self{module_name}||= do {my$module_name=$self{dist_name};$module_name =~ s/-/::/g;$module_name}if defined$self{dist_name};return bless \%self,$class}for my$attribute (keys%defaults){no strict qw/refs/;*{$attribute}=$hash_accessors{$attribute}? sub {my ($self,$key)=@_;Carp::confess("$attribute needs key")if not defined$key;return$self->{$attribute}{$key}}: $complex_accessors{$attribute}? sub {my ($self,$installdirs,$key)=@_;Carp::confess("$attribute needs installdir")if not defined$installdirs;Carp::confess("$attribute needs key")if not defined$key;return$self->{$attribute}{$installdirs}{$key}}: sub {my$self=shift;return$self->{$attribute}}}my$script=$] > 5.008000 ? 'script' : 'bin';my@install_sets_keys=qw/lib arch bin script bindoc libdoc binhtml libhtml/;my@install_sets_tail=('bin',$script,qw/man1dir man3dir html1dir html3dir/);my%install_sets_values=(core=>[qw/privlib archlib/,@install_sets_tail ],site=>[map {"site$_"}qw/lib arch/,@install_sets_tail ],vendor=>[map {"vendor$_"}qw/lib arch/,@install_sets_tail ],);sub _default_install_sets {my$c=shift;my%ret;for my$installdir (qw/core site vendor/){@{$ret{$installdir}}{@install_sets_keys}=map {$c->get("install$_")}@{$install_sets_values{$installdir}}}return \%ret}sub _default_base_relpaths {my$config=shift;return {lib=>['lib','perl5'],arch=>['lib','perl5',$config->get('archname')],bin=>['bin'],script=>['bin'],bindoc=>['man','man1'],libdoc=>['man','man3'],binhtml=>['html'],libhtml=>['html'],}}my%common_prefix_relpaths=(bin=>['bin'],script=>['bin'],bindoc=>['man','man1'],libdoc=>['man','man3'],binhtml=>['html'],libhtml=>['html'],);sub _default_prefix_relpaths {my$c=shift;my@libstyle=$c->get('installstyle')? File::Spec->splitdir($c->get('installstyle')): qw(lib perl5);my$arch=$c->get('archname');my$version=$c->get('version');return {core=>{lib=>[@libstyle],arch=>[@libstyle,$version,$arch],%common_prefix_relpaths,},vendor=>{lib=>[@libstyle],arch=>[@libstyle,$version,$arch],%common_prefix_relpaths,},site=>{lib=>[@libstyle,'site_perl'],arch=>[@libstyle,'site_perl',$version,$arch],%common_prefix_relpaths,},}}sub _default_original_prefix {my$c=shift;my%ret=(core=>$c->get('installprefixexp'),site=>$c->get('siteprefixexp'),vendor=>$c->get('usevendorprefix')? $c->get('vendorprefixexp'): '',);return \%ret}sub _log_verbose {my$self=shift;print @_ if$self->verbose;return}sub is_default_installable {my$self=shift;my$type=shift;my$installable=$self->install_destination($type)&& ($self->install_path($type)|| $self->install_sets($self->installdirs,$type));return$installable ? 1 : 0}sub _prefixify_default {my$self=shift;my$type=shift;my$rprefix=shift;my$default=$self->prefix_relpaths($self->installdirs,$type);if(!$default){$self->_log_verbose("    no default install location for type '$type', using prefix '$rprefix'.\n");return$rprefix}else {return File::Spec->catdir(@{$default})}}sub _prefixify_novms {my($self,$path,$sprefix,$type)=@_;my$rprefix=$self->prefix;$rprefix .= '/' if$sprefix =~ m{/$};$self->_log_verbose("  prefixify $path from $sprefix to $rprefix\n")if defined$path && length$path;if (not defined$path or length$path==0){$self->_log_verbose("  no path to prefixify, falling back to default.\n");return$self->_prefixify_default($type,$rprefix)}elsif(!File::Spec->file_name_is_absolute($path)){$self->_log_verbose("    path is relative, not prefixifying.\n")}elsif($path !~ s{^\Q$sprefix\E\b}{}s){$self->_log_verbose("    cannot prefixify, falling back to default.\n");return$self->_prefixify_default($type,$rprefix)}$self->_log_verbose("    now $path in $rprefix\n");return$path}sub _catprefix_vms {my ($self,$rprefix,$default)=@_;my ($rvol,$rdirs)=File::Spec->splitpath($rprefix);if ($rvol){return File::Spec->catpath($rvol,File::Spec->catdir($rdirs,$default),'')}else {return File::Spec->catdir($rdirs,$default)}}sub _prefixify_vms {my($self,$path,$sprefix,$type)=@_;my$rprefix=$self->prefix;return '' unless defined$path;$self->_log_verbose("  prefixify $path from $sprefix to $rprefix\n");require VMS::Filespec;$rprefix=VMS::Filespec::vmspath($rprefix)if$rprefix;$sprefix=VMS::Filespec::vmspath($sprefix)if$sprefix;$self->_log_verbose("  rprefix translated to $rprefix\n  sprefix translated to $sprefix\n");if (length($path)==0){$self->_log_verbose("  no path to prefixify.\n")}elsif (!File::Spec->file_name_is_absolute($path)){$self->_log_verbose("	path is relative, not prefixifying.\n")}elsif ($sprefix eq $rprefix){$self->_log_verbose("  no new prefix.\n")}else {my ($path_vol,$path_dirs)=File::Spec->splitpath($path);my$vms_prefix=$self->config->get('vms_prefix');if ($path_vol eq $vms_prefix.':'){$self->_log_verbose("  $vms_prefix: seen\n");$path_dirs =~ s{^\[}{\[.} unless$path_dirs =~ m{^\[\.};$path=$self->_catprefix_vms($rprefix,$path_dirs)}else {$self->_log_verbose("	cannot prefixify.\n");return File::Spec->catdir($self->prefix_relpaths($self->installdirs,$type))}}$self->_log_verbose("	now $path\n");return$path}BEGIN {*_prefixify=$^O eq 'VMS' ? \&_prefixify_vms : \&_prefixify_novms}sub prefix_relative {my ($self,$installdirs,$type)=@_;my$relpath=$self->install_sets($installdirs,$type);return$self->_prefixify($relpath,$self->original_prefix($installdirs),$type)}sub install_destination {my ($self,$type)=@_;return$self->install_path($type)if$self->install_path($type);if ($self->install_base){my$relpath=$self->install_base_relpaths($type);return$relpath ? File::Spec->catdir($self->install_base,@{$relpath}): undef}if ($self->prefix){my$relpath=$self->prefix_relative($self->installdirs,$type);return$relpath ? File::Spec->catdir($self->prefix,$relpath): undef}return$self->install_sets($self->installdirs,$type)}sub install_types {my$self=shift;my%types=(%{$self->{install_path}},$self->install_base ? %{$self->{install_base_relpaths}}: $self->prefix ? %{$self->{prefix_relpaths}{$self->installdirs }}: %{$self->{install_sets}{$self->installdirs }});return sort keys%types}sub install_map {my ($self,$blib)=@_;$blib ||= $self->blib;my (%map,@skipping);for my$type ($self->install_types){my$localdir=File::Spec->catdir($blib,$type);next unless -e $localdir;if (my$dest=$self->install_destination($type)){$map{$localdir}=$dest}else {push@skipping,$type}}warn "WARNING: Can't figure out install path for types: @skipping\nFiles will not be installed.\n" if@skipping;if ($self->create_packlist and my$module_name=$self->module_name){my$archdir=$self->install_destination('arch');my@ext=split /::/,$module_name;$map{write}=File::Spec->catfile($archdir,'auto',@ext,'.packlist')}if (length(my$destdir=$self->destdir || '')){for (keys%map){my ($volume,$path,$file)=File::Spec->splitpath($map{$_},0);my@dirs=File::Spec->splitdir($path);$path=File::Spec->catdir($destdir,@dirs);if ($file ne ''){$map{$_}=File::Spec->catfile($path,$file)}else {$map{$_}=$path}}}$map{read}='';return \%map}1;
EXTUTILS_INSTALLPATHS

$fatpacked{"Module/Build/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_TINY';
  package Module::Build::Tiny;$Module::Build::Tiny::VERSION='0.039';use strict;use warnings;use Exporter 5.57 'import';our@EXPORT=qw/Build Build_PL/;use CPAN::Meta;use ExtUtils::Config 0.003;use ExtUtils::Helpers 0.020 qw/make_executable split_like_shell man1_pagename man3_pagename detildefy/;use ExtUtils::Install qw/pm_to_blib install/;use ExtUtils::InstallPaths 0.002;use File::Basename qw/basename dirname/;use File::Find ();use File::Path qw/mkpath rmtree/;use File::Spec::Functions qw/catfile catdir rel2abs abs2rel splitdir curdir/;use Getopt::Long 2.36 qw/GetOptionsFromArray/;use JSON::PP 2 qw/encode_json decode_json/;sub write_file {my ($filename,$content)=@_;open my$fh,'>',$filename or die "Could not open $filename: $!\n";print$fh $content}sub read_file {my ($filename,$mode)=@_;open my$fh,'<',$filename or die "Could not open $filename: $!\n";return do {local $/;<$fh>}}sub get_meta {my ($metafile)=grep {-e $_}qw/META.json META.yml/ or die "No META information provided\n";return CPAN::Meta->load_file($metafile)}sub manify {my ($input_file,$output_file,$section,$opts)=@_;return if -e $output_file && -M $input_file <= -M $output_file;my$dirname=dirname($output_file);mkpath($dirname,$opts->{verbose})if not -d $dirname;require Pod::Man;Pod::Man->new(section=>$section)->parse_from_file($input_file,$output_file);print "Manifying $output_file\n" if$opts->{verbose}&& $opts->{verbose}> 0;return}sub process_xs {my ($source,$options)=@_;die "Can't build xs files under --pureperl-only\n" if$options->{'pureperl-only'};my (undef,@parts)=splitdir(dirname($source));push@parts,my$file_base=basename($source,'.xs');my$archdir=catdir(qw/blib arch auto/,@parts);my$tempdir='temp';my$c_file=catfile($tempdir,"$file_base.c");require ExtUtils::ParseXS;mkpath($tempdir,$options->{verbose},oct '755');ExtUtils::ParseXS::process_file(filename=>$source,prototypes=>0,output=>$c_file);my$version=$options->{meta}->version;require ExtUtils::CBuilder;my$builder=ExtUtils::CBuilder->new(config=>$options->{config}->values_set);my$ob_file=$builder->compile(source=>$c_file,defines=>{VERSION=>qq/"$version"/,XS_VERSION=>qq/"$version"/ },include_dirs=>[curdir,dirname($source)]);require DynaLoader;my$mod2fname=defined&DynaLoader::mod2fname ? \&DynaLoader::mod2fname : sub {return $_[0][-1]};mkpath($archdir,$options->{verbose},oct '755')unless -d $archdir;my$lib_file=catfile($archdir,$mod2fname->(\@parts).'.' .$options->{config}->get('dlext'));return$builder->link(objects=>$ob_file,lib_file=>$lib_file,module_name=>join '::',@parts)}sub find {my ($pattern,$dir)=@_;my@ret;File::Find::find(sub {push@ret,$File::Find::name if /$pattern/ && -f},$dir)if -d $dir;return@ret}my%actions=(build=>sub {my%opt=@_;for my$pl_file (find(qr/\.PL$/,'lib')){(my$pm=$pl_file)=~ s/\.PL$//;system $^X,$pl_file,$pm and die "$pl_file returned $?\n"}my%modules=map {$_=>catfile('blib',$_)}find(qr/\.p(?:m|od)$/,'lib');my%scripts=map {$_=>catfile('blib',$_)}find(qr//,'script');my%shared=map {$_=>catfile(qw/blib lib auto share dist/,$opt{meta}->name,abs2rel($_,'share'))}find(qr//,'share');pm_to_blib({%modules,%scripts,%shared},catdir(qw/blib lib auto/));make_executable($_)for values%scripts;mkpath(catdir(qw/blib arch/),$opt{verbose});process_xs($_,\%opt)for find(qr/.xs$/,'lib');if ($opt{install_paths}->install_destination('bindoc')&& $opt{install_paths}->is_default_installable('bindoc')){manify($_,catfile('blib','bindoc',man1_pagename($_)),$opt{config}->get('man1ext'),\%opt)for keys%scripts}if ($opt{install_paths}->install_destination('libdoc')&& $opt{install_paths}->is_default_installable('libdoc')){manify($_,catfile('blib','libdoc',man3_pagename($_)),$opt{config}->get('man3ext'),\%opt)for keys%modules}},test=>sub {my%opt=@_;die "Must run `./Build build` first\n" if not -d 'blib';require TAP::Harness::Env;my%test_args=((verbosity=>$opt{verbose})x!!exists$opt{verbose},(jobs=>$opt{jobs})x!!exists$opt{jobs},(color=>1)x!!-t STDOUT,lib=>[map {rel2abs(catdir(qw/blib/,$_))}qw/arch lib/ ],);my$tester=TAP::Harness::Env->create(\%test_args);$tester->runtests(sort +find(qr/\.t$/,'t'))->has_errors and exit 1},install=>sub {my%opt=@_;die "Must run `./Build build` first\n" if not -d 'blib';install($opt{install_paths}->install_map,@opt{qw/verbose dry_run uninst/})},clean=>sub {my%opt=@_;rmtree($_,$opt{verbose})for qw/blib temp/},realclean=>sub {my%opt=@_;rmtree($_,$opt{verbose})for qw/blib temp Build _build_params MYMETA.yml MYMETA.json/},);sub Build {my$action=@ARGV && $ARGV[0]=~ /\A\w+\z/ ? shift@ARGV : 'build';die "No such action '$action'\n" if not $actions{$action};my($env,$bargv)=@{decode_json(read_file('_build_params'))};my%opt;GetOptionsFromArray($_,\%opt,qw/install_base=s install_path=s% installdirs=s destdir=s prefix=s config=s% uninst:1 verbose:1 dry_run:1 pureperl-only:1 create_packlist=i jobs=i/)for ($env,$bargv,\@ARGV);$_=detildefy($_)for grep {defined}@opt{qw/install_base destdir prefix/},values %{$opt{install_path}};@opt{'config','meta' }=(ExtUtils::Config->new($opt{config}),get_meta());$actions{$action}->(%opt,install_paths=>ExtUtils::InstallPaths->new(%opt,dist_name=>$opt{meta}->name))}sub Build_PL {my$meta=get_meta();printf "Creating new 'Build' script for '%s' version '%s'\n",$meta->name,$meta->version;my$dir=$meta->name eq 'Module-Build-Tiny' ? "use lib 'lib';" : '';write_file('Build',"#!perl\n$dir\nuse Module::Build::Tiny;\nBuild();\n");make_executable('Build');my@env=defined$ENV{PERL_MB_OPT}? split_like_shell($ENV{PERL_MB_OPT}): ();write_file('_build_params',encode_json([\@env,\@ARGV ]));$meta->save(@$_)for ['MYMETA.json'],['MYMETA.yml'=>{version=>1.4 }]}1;
MODULE_BUILD_TINY

$fatpacked{"Object/Event.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'OBJECT_EVENT';
  package Object::Event;use common::sense;use Carp qw/croak/;use AnyEvent::Util qw/guard/;use sort 'stable';our$DEBUG=$ENV{PERL_OBJECT_EVENT_DEBUG};our$VERSION='1.23';our%PRIO_MAP=(before=>1000,ext_before=>500,ext_after=>-500,after=>-1000);sub register_priority_alias {my ($alias,$prio)=@_;$PRIO_MAP{$alias}=$prio;unless (defined$PRIO_MAP{$alias}){delete$PRIO_MAP{$alias}}}sub new {my$this=shift;my$class=ref ($this)|| $this;my$self={@_ };bless$self,$class;$self->init_object_events;return$self}sub init_object_events {my ($self)=@_;my$pkg=ref$self;_init_methods ($pkg)unless *{"$pkg\::__OE_METHODS"}{HASH};$self->{__oe_cb_gen}="a";$self->{__oe_events}={map {($_=>[@{${"$pkg\::__OE_METHODS"}{$_}}])}keys %{"$pkg\::__OE_METHODS"}}}sub set_exception_cb {my ($self,$cb)=@_;$self->{__oe_exception_cb}=$cb}our@DEBUG_STACK;sub _debug_cb {my ($callback)=@_;sub {my@a=@_;my$dbcb=$_[0]->{__oe_cbs}->[0]->[0];my$nam=$_[0]->{__oe_cbs}->[2];push@DEBUG_STACK,$dbcb;my$pad="  " x scalar@DEBUG_STACK;printf "%s-> %s\n",$pad,$dbcb->[3];eval {$callback->(@a)};my$e=$@;printf "%s<- %s\n",$pad,$dbcb->[3];pop@DEBUG_STACK;die$e if$e;()}}sub _print_event_debug {my ($ev)=@_;my$pad="  " x scalar@DEBUG_STACK;my ($pkg,$file,$line)=caller (1);for my$path (@INC){last if$file =~ s/^\Q$path\E\/?//}printf "%s!! %s @ %s:%d (%s::)\n",$pad,$ev,$file,$line,$pkg}sub _register_event_struct {my ($self,$event,$prio,$gen,$callback,$debug)=@_;my$reg=($self->{__oe_events}||= {});my$idx=0;$reg->{$event}||= [];my$evlist=$reg->{$event};for my$ev (@$evlist){last if$ev->[0]< $prio;$idx++}my$cb=$callback;$cb=_debug_cb ($callback)if$DEBUG > 1;splice @$evlist,$idx,0,[$prio,"$callback|$gen",undef,$debug,$cb]}sub reg_cb {my ($self,@args)=@_;my$debuginfo=caller;if ($DEBUG > 0){my ($pkg,$file,$line)=caller;for my$path (@INC){last if$file =~ s/^\Q$path\E\/?//}$debuginfo=sprintf "%s:%d (%s::)",$file,$line,$pkg}my$gen=$self->{__oe_cb_gen}++;my@cbs;while (@args){my ($ev,$sec)=(shift@args,shift@args);my ($prio,$cb)=(0,undef);if (ref$sec){for my$prefix (keys%PRIO_MAP){if ($ev =~ s/^(\Q$prefix\E)_//){$prio=$PRIO_MAP{$prefix};last}}$cb=$sec}else {$prio=$sec;$cb=shift@args}$self->_register_event_struct ($ev,$prio,$gen,$cb,$debuginfo);push@cbs,$cb}defined wantarray ? \(my$g=guard {if ($self){$self->unreg_cb ($_,$gen)for@cbs}}): ()}sub unreg_cb {my ($self,$cb,$gen)=@_;if (ref ($cb)eq 'REF'){$$cb=undef;return}return unless defined$cb;my$evs=$self->{__oe_events};my ($key,$key_len)=defined$gen ? ("$cb|$gen",length "$cb|$gen"): ("$cb",length "$cb");for my$reg (values %$evs){@$reg=grep {(substr $_->[1],0,$key_len)ne $key}@$reg}}sub event {my ($self,$ev,@arg)=@_;my@cbs;if (ref ($ev)eq 'ARRAY'){@cbs=@$ev}else {my$evs=$self->{__oe_events}->{$ev}|| [];@cbs=@$evs}if ($self->{__oe_forwards}){my$idx=0;for my$ev (@cbs){last if$ev->[0]<= 0;$idx++}my$cb=sub {for my$fw (keys %{$self->{__oe_forwards}}){my$f=$self->{__oe_forwards}->{$fw};local$f->[0]->{__oe_forward_stop}=0;eval {$f->[1]->($self,$f->[0],$ev,@arg)};if ($@){if ($self->{__oe_exception_cb}){$self->{__oe_exception_cb}->($@,$ev)}else {warn "unhandled callback exception on forward event " ."($ev, $self, $f->[0], @arg): $@\n"}}elsif ($f->[0]->{__oe_forward_stop}){$self->stop_event}}};splice@cbs,$idx,0,[0,"$cb",undef,undef,$cb]}_print_event_debug ($ev)if$DEBUG > 1;return unless@cbs;local$self->{__oe_cbs}=[\@cbs,\@arg,$ev];eval {$cbs[0]->[4]->($self,@arg),shift@cbs while@cbs;()};if ($@){if (not ($self->{__oe_exception_rec})&& $self->{__oe_exception_cb}){local$self->{__oe_exception_rec}=[$ev,$self,@arg];$self->{__oe_exception_cb}->($@,$ev)}elsif ($self->{__oe_exception_rec}){warn "recursion through exception callback " ."(@{$self->{__oe_exception_rec}}) => " ."($ev, $self, @arg): $@\n"}else {warn "unhandled callback exception on event ($ev, $self, @arg): $@\n"}}1}sub handles {my ($self,$ev)=@_;exists$self->{__oe_events}->{$ev}&& @{$self->{__oe_events}->{$ev}}> 0}sub event_name {my ($self)=@_;return unless$self->{__oe_cbs};$self->{__oe_cbs}->[2]}sub unreg_me {my ($self)=@_;return unless$self->{__oe_cbs}&& @{$self->{__oe_cbs}->[0]};$self->unreg_cb ($self->{__oe_cbs}->[0]->[0]->[1])}sub stop_event {my ($self)=@_;return unless$self->{__oe_cbs}&& @{$self->{__oe_cbs}->[0]};my$r;if (defined wantarray){my@ev=([@{$self->{__oe_cbs}->[0]}],@{$self->{__oe_cbs}->[1]});shift @{$ev[0]};$r=sub {$self->event (@ev)}}$self->{__oe_forward_stop}=1;@{$self->{__oe_cbs}->[0]}=();$r}sub add_forward {my ($self,$obj,$cb)=@_;$self->{__oe_forwards}->{$obj}=[$obj,$cb]}sub remove_forward {my ($self,$obj)=@_;delete$self->{__oe_forwards}->{$obj};if (scalar (keys %{$self->{__oe_forwards}})<= 0){delete$self->{__oe_forwards}}}sub _event {my$self=shift;$self->event (@_)}sub remove_all_callbacks {my ($self)=@_;$self->{__oe_events}={};delete$self->{__oe_exception_cb}}sub events_as_string_dump {my ($self)=@_;my$str='';for my$ev (keys %{$self->{__oe_events}}){my$evr=$self->{__oe_events}->{$ev};$str .= "$ev:\n" .join ('',map {sprintf "   %5d %s\n",$_->[0],$_->[3]}@$evr)."\n"}$str}our%ATTRIBUTES;sub FETCH_CODE_ATTRIBUTES {my ($pkg,$ref)=@_;return ()unless exists$ATTRIBUTES{$pkg};return ()unless exists$ATTRIBUTES{$pkg}->{"$ref"};my$a=$ATTRIBUTES{$pkg}->{"$ref"};'event_cb' .(($a->[0]ne '' || defined ($b->[1]))? "($a->[0],$b->[1])" : '')}sub MODIFY_CODE_ATTRIBUTES {my ($pkg,$ref,@attrs)=@_;grep {my$unhandled=1;if ($_ =~ /^event_cb (?:
                     \(
                         \s* ([^\),]*) \s*
                         (?: , \s* ([^\)]+) \s* )?
                     \)
                 )?$/x){$ATTRIBUTES{$pkg}->{"$ref"}=[$1,$2];$unhandled=0}$unhandled}@attrs}sub _init_methods {my ($pkg)=@_;my$pkg_meth=\%{"$pkg\::__OE_METHODS"};for my$superpkg (@{"$pkg\::ISA"}){next unless$superpkg->isa ("Object::Event");_init_methods ($superpkg)unless *{"$superpkg\::__OE_METHODS"}{HASH};for (keys %{"$superpkg\::__OE_METHODS"}){push @{$pkg_meth->{$_}},@{${"$superpkg\::__OE_METHODS"}{$_}|| []}}}my%mymethds;for my$realmeth (keys %{"$pkg\::"}){my$coderef=*{"$pkg\::$realmeth"}{CODE};next unless exists$ATTRIBUTES{$pkg}->{"$coderef"};my$m=$ATTRIBUTES{$pkg}->{"$coderef"};my$meth=$realmeth;if (defined$m->[1]){$meth=$m->[1]}my$cb=$coderef;$cb=_debug_cb ($coderef)if$DEBUG > 1;push @{$mymethds{$meth}},[(exists$PRIO_MAP{$m->[0]}? $PRIO_MAP{$m->[0]}: 0+$m->[0]),"$coderef",$realmeth,$pkg .'::' .$realmeth,$cb ]if defined &{"$pkg\::$realmeth"};_replace_method ($pkg,$realmeth,$meth)}for my$ev (keys%mymethds){@{$mymethds{$ev}}=sort {$a->[2]cmp $b->[2]}@{$mymethds{$ev}}}push @{$pkg_meth->{$_}},@{$mymethds{$_}}for keys%mymethds;for my$ev (keys %$pkg_meth){@{$pkg_meth->{$ev}}=sort {$b->[0]<=> $a->[0]}@{$pkg_meth->{$ev}}}}sub _replace_method {my ($pkg,$meth,$ev)=@_;*{"$pkg\::$meth"}=sub {my ($self,@arg)=@_;_print_event_debug ($ev)if$DEBUG > 1;my@cbs=@{$self->{__oe_events}->{$ev}|| ${"$pkg\::__OE_METHODS"}{$ev}|| []};local$self->{__oe_cbs}=[\@cbs,\@arg,$ev];eval {$cbs[0]->[4]->($self,@arg),shift@cbs while@cbs;()};if ($@){if (not ($self->{__oe_exception_rec})&& $self->{__oe_exception_cb}){local$self->{__oe_exception_rec}=[$ev,$self,@arg];$self->{__oe_exception_cb}->($@,$ev)}elsif ($self->{__oe_exception_rec}){warn "recursion through exception callback " ."(@{$self->{__oe_exception_rec}}) => " ."($ev, $self, @arg): $@\n"}else {warn "unhandled callback exception on event " ."($ev, $self, @arg): $@\n"}}@cbs > 0}}1;
OBJECT_EVENT

$fatpacked{"common/sense.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'COMMON_SENSE';
  package common::sense;our$VERSION=3.74;sub import {local $^W;${^WARNING_BITS} ^= ${^WARNING_BITS} ^ "\x0c\x3f\x33\x00\x0f\xf0\x0f\xc0\xf0\xfc\x33\x00\x00\x00\xc0";$^H |= 0x1c820fc0;@^H{qw(feature___SUB__ feature_evalbytes feature_unicode feature_state feature_switch feature_say feature_fc)}=(1)x 7}1
COMMON_SENSE

$fatpacked{"parent.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PARENT';
  package parent;use strict;use vars qw($VERSION);$VERSION='0.234';sub import {my$class=shift;my$inheritor=caller(0);if (@_ and $_[0]eq '-norequire'){shift @_}else {for (my@filename=@_){s{::|'}{/}g;require "$_.pm"}}{no strict 'refs';push @{"$inheritor\::ISA"},@_}};"All your base are belong to us" 
PARENT

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
     if (my $fat = $_[0]{$_[1]}) {
       return sub {
         return 0 unless length $fat;
         $fat =~ s/^([^\n]*\n?)//;
         $_ = $1;
         return 1;
       };
     }
     return;
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

use strict;
use warnings;
use App::irccat;

exit(App::irccat->new->run(@ARGV));
